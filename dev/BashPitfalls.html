<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">

<title>BashPitfalls - Greg's Wiki</title>
<script type="text/javascript" src="/moin_static198/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>

<script type="text/javascript">
<!-- // GUI edit link and i18n
var gui_editor_link_href = "/BashPitfalls?action=edit&editor=gui";
var gui_editor_link_text = "Edit (GUI)";
//-->
</script>

<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/moin_static198/modernized/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="/moin_static198/modernized/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="/moin_static198/modernized/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="/moin_static198/modernized/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/moin_static198/modernized/css/msie.css">
<![endif]-->


<link rel="alternate" title="Greg's Wiki: BashPitfalls" href="/BashPitfalls?diffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=BashPitfalls&amp;ddiffs=1" type="application/rss+xml">
<link rel="alternate" type="application/wiki" title="Edit" href="/BashPitfalls?action=edit">

<link rel="Start" href="/EnglishFrontPage">
<link rel="Alternate" title="Wiki Markup" href="/BashPitfalls?action=raw">
<link rel="Alternate" media="print" title="Print View" href="/BashPitfalls?action=print">
<link rel="Appendix" title="package.zip" href="/BashPitfalls?action=AttachFile&amp;do=view&amp;target=package.zip">
<link rel="Search" href="/FindPage">
<link rel="Index" href="/TitleIndex">
<link rel="Glossary" href="/WordIndex">
<link rel="Help" href="/HelpOnFormatting">
</head>

<body  lang="en" dir="ltr">

<div id="header">

<form id="searchform" method="get" action="/BashPitfalls">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<div id="logo"><a href="/EnglishFrontPage"><img src="/moin_static198/common/moinmoin.png" alt="MoinMoin Logo"></a></div>
<div id="username"><a href="/BashPitfalls?action=login" id="login" rel="nofollow">Login</a></div>
<h1 id="locationline">

<span id="pagelocation"><a href="/BashPitfalls">BashPitfalls</a></span>
</h1>


<ul id="navibar">
<li class="wikilink"><a href="/BashGuide">BashGuide</a></li><li class="wikilink"><a href="/BashFAQ">BashFAQ</a></li><li class="wikilink"><a href="/RecentChanges">RecentChanges</a></li><li class="wikilink"><a href="/FindPage">FindPage</a></li><li class="wikilink"><a href="/HelpContents">HelpContents</a></li><li class="current"><a href="/BashPitfalls">BashPitfalls</a></li>
</ul>

<div id="pageline"><hr style="display:none;"></div>

<ul class="editbar"><li><a href="/BashPitfalls?action=edit&amp;editor=text" name="texteditlink" rel="nofollow">Edit (Text)</a></li><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="/BashPitfalls?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="/BashPitfalls?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="/BashPitfalls">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="RenderAsDocbook">Render as Docbook</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
<option value="PackagePages">Package Pages</option>
<option value="SyncPages">Sync Pages</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="Load">Load</option>
<option value="Save">Save</option>
<option value="SlideShow">SlideShow</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line867">
<h1 id="Bash_Pitfalls">Bash Pitfalls</h1>
<span class="anchor" id="line-5"></span><p class="line874">This page is a compilation of common mistakes made by bash users. Each example is flawed in some way. <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#for_f_in_.24.28ls_.2A.mp3.29">for f in $(ls *.mp3)</a></li><li>
<a href="#cp_.24file_.24target">cp $file $target</a></li><li>
<a href="#Filenames_with_leading_dashes">Filenames with leading dashes</a></li><li>
<a href="#A.5B_.24foo_.3D_.22bar.22_.5D">[ $foo = "bar" ]</a></li><li>
<a href="#cd_.24.28dirname_.22.24f.22.29">cd $(dirname "$f")</a></li><li>
<a href="#A.5B_.22.24foo.22_.3D_bar_.26.26_.22.24bar.22_.3D_foo_.5D">[ "$foo" = bar &amp;&amp; "$bar" = foo ]</a></li><li>
<a href="#A.5B.5B_.24foo_.3E_7_.5D.5D">[[ $foo &gt; 7 ]]</a></li><li>
<a href="#grep_foo_bar_.7C_while_read_-r.3B_do_.28.28count.2B-.2B-.29.29.3B_done">grep foo bar | while read -r; do ((count++)); done</a></li><li>
<a href="#if_.5Bgrep_foo_myfile.5D">if [grep foo myfile]</a></li><li>
<a href="#if_.5Bbar.3D.22.24foo.22.5D.3B_then_...">if [bar="$foo"]; then ...</a></li><li>
<a href="#if_.5B_.5B_a_.3D_b_.5D_.26.26_.5B_c_.3D_d_.5D_.5D.3B_then_...">if [ [ a = b ] &amp;&amp; [ c = d ] ]; then ...</a></li><li>
<a href="#read_.24foo">read $foo</a></li><li>
<a href="#cat_file_.7C_sed_s.2Ffoo.2Fbar.2F_.3E_file">cat file | sed s/foo/bar/ &gt; file</a></li><li>
<a href="#echo_.24foo">echo $foo</a></li><li>
<a href="#A.24foo.3Dbar">$foo=bar</a></li><li>
<a href="#foo_.3D_bar">foo = bar</a></li><li>
<a href="#echo_.3C.3CEOF">echo &lt;&lt;EOF</a></li><li>
<a href="#su_-c_.27some_command.27">su -c 'some command'</a></li><li>
<a href="#cd_.2Ffoo.3B_bar">cd /foo; bar</a></li><li>
<a href="#A.5B_bar_.3D.3D_.22.24foo.22_.5D">[ bar == "$foo" ]</a></li><li>
<a href="#for_i_in_.7B1..10.7D.3B_do_..2Fsomething_.26.3B_done">for i in {1..10}; do ./something &amp;; done</a></li><li>
<a href="#cmd1_.26.26_cmd2_.7C.7C_cmd3">cmd1 &amp;&amp; cmd2 || cmd3</a></li><li>
<a href="#echo_.22Hello_World.21.22">echo "Hello World!"</a></li><li>
<a href="#for_arg_in_.24.2A">for arg in $*</a></li><li>
<a href="#function_foo.28.29">function foo()</a></li><li>
<a href="#echo_.22.2BAH4.22">echo "~"</a></li><li>
<a href="#local_var.3D.24.28cmd.29">local var=$(cmd)</a></li><li>
<a href="#export_foo.3D.2BAH4-.2Fbar">export foo=~/bar</a></li><li>
<a href="#sed_.27s.2F.24foo.2Fgood_bye.2F.27">sed 's/$foo/good bye/'</a></li><li>
<a href="#tr_.5BA-Z.5D_.5Ba-z.5D">tr [A-Z] [a-z]</a></li><li>
<a href="#ps_ax_.7C_grep_gedit">ps ax | grep gedit</a></li><li>
<a href="#printf_.22.24foo.22">printf "$foo"</a></li><li>
<a href="#for_i_in_.7B1...24n.7D">for i in {1..$n}</a></li><li>
<a href="#if_.5B.5B_.24foo_.3D_.24bar_.5D.5D_.28depending_on_intent.29">if [[ $foo = $bar ]] (depending on intent)</a></li><li>
<a href="#if_.5B.5B_.24foo_.3D.2BAH4_.27some_RE.27_.5D.5D">if [[ $foo =~ 'some RE' ]]</a></li><li>
<a href="#A.5B_-n_.24foo_.5D_or_.5B_-z_.24foo_.5D">[ -n $foo ] or [ -z $foo ]</a></li><li>
<a href="#A.5B.5B_-e_.22.24broken_symlink.22_.5D.5D_returns_1_even_though_.24broken_symlink_exists">[[ -e "$broken_symlink" ]] returns 1 even though $broken_symlink exists</a></li><li>
<a href="#ed_file_.3C.3C.3C.22g.2Fd.2BAFw.7B0.2C3.2BAFw.7D.2Fs.2F.2Fe.2Fg.22_fails">ed file &lt;&lt;&lt;"g/d\{0,3\}/s//e/g" fails</a></li><li>
<a href="#expr_sub-string_fails_for_.22match.22">expr sub-string fails for "match"</a></li><li>
<a href="#On_UTF-8_and_Byte-Order_Marks_.28BOM.29">On UTF-8 and Byte-Order Marks (BOM)</a></li><li>
<a href="#content.3D.24.28.3Cfile.29">content=$(&lt;file)</a></li><li>
<a href="#for_file_in_..2F.2A_.3B_do_if_.5B.5B_.24file_.21.3D_.2A..2A_.5D.5D">for file in ./* ; do if [[ $file != *.* ]]</a></li><li>
<a href="#somecmd_2.3E.261_.3E.3Elogfile">somecmd 2&gt;&amp;1 &gt;&gt;logfile</a></li><li>
<a href="#cmd.3B_.28.28_.21_.24.3F_.29.29_.7C.7C_die">cmd; (( ! $? )) || die</a></li><li>
<a href="#y.3D.24.28.28_array.5B.24x.5D_.29.29">y=$(( array[$x] ))</a></li><li>
<a href="#read_num.3B_echo_.24.28.28num.2B-1.29.29">read num; echo $((num+1))</a></li><li>
<a href="#IFS.3D.2C_read_-ra_fields_.3C.3C.3C_.22.24csv_line.22">IFS=, read -ra fields &lt;&lt;&lt; "$csv_line"</a></li><li>
<a href="#export_CDPATH.3D.:.2BAH4-.2FmyProject">export CDPATH=.:~/myProject</a></li><li>
<a href="#OIFS.3D.22.24IFS.22.3B_....3B_IFS.3D.22.24OIFS.22">OIFS="$IFS"; ...; IFS="$OIFS"</a></li><li>
<a href="#hosts.3D.28_.24.28aws_....29_.29">hosts=( $(aws ...) )</a></li><li>
<a href="#Non-atomic_writes_with_xargs_-P">Non-atomic writes with xargs -P</a></li><li>
<a href="#find_._-exec_sh_-c_.27echo_.7B.7D.27_.2BAFw.3B">find . -exec sh -c 'echo {}' \;</a></li><li>
<a href="#sudo_mycmd_.3E_.2Fmyfile">sudo mycmd &gt; /myfile</a></li><li>
<a href="#sudo_ls_.2Ffoo.2F.2A">sudo ls /foo/*</a></li><li>
<a href="#myprogram_2.3E.26-">myprogram 2&gt;&amp;-</a></li><li>
<a href="#Using_xargs_without_-0">Using xargs without -0</a></li><li>
<a href="#unset_a.5B0.5D">unset a[0]</a></li><li>
<a href="#month.3D.24.28date_.2B-.25m.29.3B_day.3D.24.28date_.2B-.25d.29">month=$(date +%m); day=$(date +%d)</a></li><li>
<a href="#i.3D.24.28.28_10.23.24i_.29.29">i=$(( 10#$i ))</a></li></ol></li></ol></div> <span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line867"><span class="anchor" id="pf1"></span> <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line867">
<h2 id="for_f_in_.24.28ls_.2A.mp3.29">1. for f in $(ls *.mp3)</h2>
<span class="anchor" id="line-12"></span><p class="line862">One of the most common mistakes <a href="/BASH">BASH</a> programmers make is to write a loop like this: <span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span><p class="line867"><span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><pre><span class="anchor" id="line-1"></span>for f in $(ls *.mp3); do    # Wrong!
<span class="anchor" id="line-2"></span>    some command $f         # Wrong!
<span class="anchor" id="line-3"></span>done
<span class="anchor" id="line-4"></span>
<span class="anchor" id="line-5"></span>for f in $(ls)              # Wrong!
<span class="anchor" id="line-6"></span>for f in `ls`               # Wrong!
<span class="anchor" id="line-7"></span>
<span class="anchor" id="line-8"></span>for f in $(find . -type f)  # Wrong!
<span class="anchor" id="line-9"></span>for f in `find . -type f`   # Wrong!
<span class="anchor" id="line-10"></span>
<span class="anchor" id="line-11"></span>files=($(find . -type f))   # Wrong!
<span class="anchor" id="line-12"></span>for f in ${files[@]}        # Wrong!</pre><span class="anchor" id="line-28"></span><p class="line862">Yes, it would be great if you could just treat the output of <tt class="backtick">ls</tt> or <tt class="backtick">find</tt> as a list of filenames and iterate over it.  But you <strong>cannot</strong>.  This entire approach is fatally flawed, and there is no trick that can make it work.  You must use an entirely different approach. <span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span><p class="line874">There are at least 6 problems with this: <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><ol type="1"><li><p class="line862">If a filename contains whitespace, it undergoes <a href="/WordSplitting">WordSplitting</a>.  Assuming we have a file named <tt class="backtick">01&nbsp;-&nbsp;Don't&nbsp;Eat&nbsp;the&nbsp;Yellow&nbsp;Snow.mp3</tt> in the current directory, the <tt class="backtick">for</tt> loop will iterate over each word in the resulting file name: <em>01</em>, <em>-</em>, <em>Don't</em>, <em>Eat</em>, etc. <span class="anchor" id="line-33"></span></li><li><p class="line862">If a filename contains <a href="/glob">glob</a> characters, it undergoes filename expansion ("<a href="/glob">globbing</a>").  If <tt class="backtick">ls</tt> produces any output containing a <strong>*</strong> character, the word containing it will become recognized as a pattern and substituted with a list of all filenames that match it. <span class="anchor" id="line-34"></span></li><li><p class="line862">If the command substitution returns multiple filenames, there is no way to tell where the first one ends and the second one begins.  Pathnames may contain <em>any</em> character except NUL.  Yes, this includes newlines. <span class="anchor" id="line-35"></span></li><li><p class="line862">The <tt class="backtick">ls</tt> utility may mangle filenames.  Depending on which platform you're on, which arguments you used (or didn't use), and whether its standard output is pointing to a terminal or not, <tt class="backtick">ls</tt> may randomly decide to replace certain characters in a filename with "?", or simply not print them at all. <a href="/ParsingLs">Never try to parse the output of ls</a>. <tt class="backtick">ls</tt> is just plain unnecessary. It's an external command whose output is intended specifically to be read by a human, not parsed by a script. <span class="anchor" id="line-36"></span></li><li><p class="line862">The <a href="/CommandSubstitution">CommandSubstitution</a> strips <em>all</em> trailing newline characters from its output.  That may seem desirable since <tt class="backtick">ls</tt> adds a newline, but if the last filename in the list ends with a newline, <tt>`...`</tt> or <tt class="backtick">$()</tt> will remove <em>that</em> one also. <span class="anchor" id="line-37"></span></li><li><p class="line862">In the <tt class="backtick">ls</tt> examples, if the first filename starts with a hyphen, it may lead to <a href="/BashPitfalls#pf3">pitfall #3</a>. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span></li></ol><p class="line874">You can't simply double-quote the substitution either: <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line867"><span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><pre><span class="anchor" id="line-1-1"></span>for f in "$(ls *.mp3)"; do     # Wrong!</pre><span class="anchor" id="line-44"></span><p class="line862">This causes the entire output of <tt class="backtick">ls</tt> to be treated as a single word. Instead of iterating over each file name, the loop will only execute <em>once</em>, assigning to <tt class="backtick">f</tt> a string with all the filenames rammed together. <span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><p class="line862">Nor can you simply change <a href="/IFS">IFS</a> to a newline.  Filenames can also contain newlines. <span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><p class="line862">Another variation on this theme is abusing word splitting and a <tt class="backtick">for</tt> loop to (incorrectly) read lines of a file.  For example: <span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><p class="line867"><span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><pre><span class="anchor" id="line-1-2"></span>IFS=$'\n'
<span class="anchor" id="line-2-1"></span>for line in $(cat file); do ...     # Wrong!</pre><span class="anchor" id="line-54"></span><p class="line867"><a href="/DontReadLinesWithFor">This doesn't work</a>!  Especially if those lines are filenames.  Bash (or any other Bourne family shell) just doesn't work this way. <span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><p class="line867"><strong>So, what's the right way to do it?</strong> <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><p class="line874">There are several ways, primarily depending on whether you need a recursive expansion or not. <span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line862">If you don't need recursion, you can use a simple <a href="/glob">glob</a>.  Instead of <tt class="backtick">ls</tt>: <span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line867"><span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><pre><span class="anchor" id="line-1-3"></span>for file in ./*.mp3; do    # Better! and...
<span class="anchor" id="line-2-2"></span>    some command "$file"   # ...always double-quote expansions!
<span class="anchor" id="line-3-1"></span>done</pre><span class="anchor" id="line-67"></span><p class="line862">POSIX shells such as Bash have the globbing feature specifically for this purpose -- to allow the shell to expand patterns into a list of matching filenames. There is no need to interpret the results of an external utility. Because globbing is the very last expansion step, each match of the <tt class="backtick">./*.mp3</tt> pattern correctly expands to a separate word, and isn't subject to the effects of an unquoted expansion. <span class="anchor" id="line-68"></span><span class="anchor" id="line-69"></span><p class="line867"><em>Question:</em> What happens if there are no *.mp3-files in the current directory? Then the for loop is executed once, with file="./*.mp3", which is not the expected behavior! The workaround is to test whether there is a matching file: <span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><p class="line867"><span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><span class="anchor" id="line-76"></span><span class="anchor" id="line-77"></span><pre><span class="anchor" id="line-1-4"></span># POSIX
<span class="anchor" id="line-2-3"></span>for file in ./*.mp3; do
<span class="anchor" id="line-3-2"></span>    [ -e "$file" ] || continue
<span class="anchor" id="line-4-1"></span>    some command "$file"
<span class="anchor" id="line-5-1"></span>done</pre><span class="anchor" id="line-78"></span><p class="line862">Another solution is to use Bash's <tt class="backtick">shopt&nbsp;-s&nbsp;nullglob</tt> feature, though this should only be done after reading the documentation and carefully considering the effect of this setting on all other globs in the script. <span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line862">If you need recursion, the standard solution is <tt class="backtick">find</tt>.  When <a href="/UsingFind">using find</a>, be sure you use it properly.  For POSIX sh portability, use the <tt class="backtick">-exec</tt> option: <span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><p class="line867"><span class="anchor" id="line-83"></span><span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><span class="anchor" id="line-88"></span><pre><span class="anchor" id="line-1-5"></span>find . -type f -name '*.mp3' -exec some command {} \;
<span class="anchor" id="line-2-4"></span>
<span class="anchor" id="line-3-3"></span># Or, if the command accepts multiple input filenames:
<span class="anchor" id="line-4-2"></span>
<span class="anchor" id="line-5-2"></span>find . -type f -name '*.mp3' -exec some command {} +</pre><span class="anchor" id="line-89"></span><p class="line862">If you're using bash, then you have two additional options.  One is to use GNU or BSD <tt class="backtick">find</tt>'s <tt class="backtick">-print0</tt> option, together with bash's <tt class="backtick">read&nbsp;-d&nbsp;''</tt> option and a <a href="/ProcessSubstitution">ProcessSubstitution</a>: <span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><p class="line867"><span class="anchor" id="line-92"></span><span class="anchor" id="line-93"></span><span class="anchor" id="line-94"></span><span class="anchor" id="line-95"></span><pre><span class="anchor" id="line-1-6"></span>while IFS= read -r -d '' file; do
<span class="anchor" id="line-2-5"></span>  some command "$file"
<span class="anchor" id="line-3-4"></span>done &lt; &lt;(find . -type f -name '*.mp3' -print0)</pre><span class="anchor" id="line-96"></span><p class="line862">The advantage here is that "some command" (indeed, the entire <tt class="backtick">while</tt> loop body) is executed in the current shell.  You can set variables and have them <a href="/BashFAQ/024">persist after the loop ends</a>. <span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><p class="line862">The other option, available in <a href="/BashFAQ/061">Bash 4.0 and higher</a>, is <tt class="backtick">globstar</tt>, which permits a glob to be expanded recursively: <span class="anchor" id="line-99"></span><span class="anchor" id="line-100"></span><p class="line867"><span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><pre><span class="anchor" id="line-1-7"></span>shopt -s globstar
<span class="anchor" id="line-2-6"></span>for file in ./**/*.mp3; do
<span class="anchor" id="line-3-5"></span>  some command "$file"
<span class="anchor" id="line-4-3"></span>done</pre><span class="anchor" id="line-106"></span><p class="line862">Note the double quotes around <tt class="backtick">$file</tt> in the examples above. This leads to our second pitfall: <span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span><p class="line867"><span class="anchor" id="pf2"></span> <span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><p class="line867">
<h2 id="cp_.24file_.24target">2. cp $file $target</h2>
<span class="anchor" id="line-111"></span><p class="line862">What's wrong with the command shown above? Well, nothing, <strong>if</strong> you happen to know in advance that <tt class="backtick">$file</tt> and <tt class="backtick">$target</tt> have no white space or <a href="/glob">wildcards</a> in them. However, the results of the expansions are still subject to <a href="/WordSplitting">WordSplitting</a> and <a href="/glob">pathname expansion</a>. Always double-quote parameter expansions. <span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><p class="line867"><span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><pre><span class="anchor" id="line-1-8"></span>cp -- "$file" "$target"</pre><span class="anchor" id="line-116"></span><p class="line862">Without the double quotes, you'll get a command like <tt class="backtick">cp&nbsp;01&nbsp;-&nbsp;Don't&nbsp;Eat&nbsp;the&nbsp;Yellow&nbsp;Snow.mp3&nbsp;/mnt/usb</tt>, which will result in errors like <tt>cp:&nbsp;cannot&nbsp;stat&nbsp;`01':&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory</tt>. If <tt class="backtick">$file</tt> has wildcards in it (<strong>*</strong> or <strong>?</strong> or <strong>[</strong>), they will be <a href="/glob">expanded</a> if there are files that match them. With the double quotes, all's well, unless "$file" happens to start with a <tt class="backtick">-</tt>, in which case <tt class="backtick">cp</tt> thinks you're trying to feed it command line options (See <a href="/BashPitfalls#pf3">pitfall #3</a> below.) <span class="anchor" id="line-117"></span><span class="anchor" id="line-118"></span><p class="line862">Even in the somewhat uncommon circumstance that you can guarantee the variable contents, it is conventional and good practice to <a href="/Quotes">quote</a> parameter expansions, especially if they contain file names. Experienced script writers will always use <a href="/Quotes">quotes</a> except perhaps for a small number of cases in which it is <em>absolutely</em> obvious from the immediate code context that a parameter contains a guaranteed safe value. Experts will most likely consider the <tt class="backtick">cp</tt> command in the title always wrong. You should too. <span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line867"><span class="anchor" id="pf3"></span> <span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line867">
<h2 id="Filenames_with_leading_dashes">3. Filenames with leading dashes</h2>
<span class="anchor" id="line-123"></span><p class="line862">Filenames with leading dashes can cause many problems. Globs like <tt class="backtick">*.mp3</tt> are sorted into an expanded list (according to your current <a href="/locale">locale</a>), and <tt class="backtick">-</tt> sorts before letters in most locales. The list is then passed to some command, which may incorrectly interpret the <tt class="backtick">-filename</tt> as an option. There are two major solutions to this. <span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line862">One solution is to insert <tt class="backtick">--</tt> between the command (like <tt class="backtick">cp</tt>) and its arguments. That tells it to stop scanning for options, and all is well: <span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><p class="line867"><span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><pre><span class="anchor" id="line-1-9"></span>cp -- "$file" "$target"</pre><span class="anchor" id="line-130"></span><p class="line862">There are potential problems with this approach. You have to be sure to insert <tt class="backtick">--</tt> for <em>every</em> usage of the parameter in a context where it might possibly be interpreted as an option -- which is easy to miss and may involve a lot of redundancy. <span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><p class="line862">Most well-written option parsing libraries understand this, and the programs that use them correctly should inherit that feature for free. However, still be aware that it is ultimately up to the application to recognize <em>end of options</em>. Some programs that manually parse options, or do it incorrectly, or use poor 3rd-party libraries may not recognize it. Standard utilities <em>should</em>, with a few exceptions that are specified by POSIX. <tt class="backtick">echo</tt> is one example. <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line874">Another option is to ensure that your filenames always begin with a directory by using relative or absolute pathnames. <span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line867"><span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><pre><span class="anchor" id="line-1-10"></span>for i in ./*.mp3; do
<span class="anchor" id="line-2-7"></span>    cp "$i" /target
<span class="anchor" id="line-3-6"></span>    ...
<span class="anchor" id="line-4-4"></span>done</pre><span class="anchor" id="line-142"></span><p class="line862">In this case, even if we have a file whose name begins with <tt class="backtick">-</tt>, the glob will ensure that the variable always contains something like <tt class="backtick">./-foo.mp3</tt>, which is perfectly safe as far as <tt class="backtick">cp</tt> is concerned. <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line874">Finally, if you can guarantee that all results will have the same prefix, and are only using the variable a few times within a loop body, you can simply concatenate the prefix with the expansion. This gives a theoretical savings in generating and storing a few extra characters for each word. <span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><p class="line867"><span class="anchor" id="line-147"></span><span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><pre><span class="anchor" id="line-1-11"></span>for i in *.mp3; do
<span class="anchor" id="line-2-8"></span>    cp "./$i" /target
<span class="anchor" id="line-3-7"></span>    ...
<span class="anchor" id="line-4-5"></span>done</pre><span class="anchor" id="line-152"></span><p class="line867"><span class="anchor" id="pf4"></span> <span class="anchor" id="line-153"></span><span class="anchor" id="line-154"></span><p class="line867">
<h2 id="A.5B_.24foo_.3D_.22bar.22_.5D">4. [ $foo = "bar" ]</h2>
<span class="anchor" id="line-155"></span><p class="line862">This is very similar to the issue in pitfall #2, but I repeat it because it's <em>so</em> important. In the example above, the <a href="/Quotes">quotes</a> are in the wrong place. You do <em>not</em> need to quote a string literal in bash (unless it contains metacharacters or pattern characters). But you <em>should</em> quote your variables if you aren't sure whether they could contain white space or wildcards. <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line874">This example can break for several reasons: <span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><ul><li><p class="line862">If a variable referenced in <tt class="backtick">[</tt> doesn't exist, or is blank, then the <tt class="backtick">[</tt> command would end up looking like: <span class="anchor" id="line-160"></span></li><li style="list-style-type:none"><span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><pre><span class="anchor" id="line-1-12"></span>[ = "bar" ] # Wrong!</pre><span class="anchor" id="line-163"></span></li><li style="list-style-type:none"><p class="line862">...and will throw the error: <tt class="backtick">unary&nbsp;operator&nbsp;expected</tt>. (The <tt class="backtick">=</tt> operator is <em>binary</em>, not unary, so the <tt class="backtick">[</tt> command is rather shocked to see it there.) <span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span></li><li class="gap"><p class="line862">If the variable contains internal whitespace, then it gets <a href="/WordSplitting">split into separate words</a> before the <tt class="backtick">[</tt> command sees it. Thus: <span class="anchor" id="line-166"></span></li><li style="list-style-type:none"><span class="anchor" id="line-167"></span><span class="anchor" id="line-168"></span><pre><span class="anchor" id="line-1-13"></span>[ multiple words here = "bar" ]</pre><span class="anchor" id="line-169"></span></li><li style="list-style-type:none"><p class="line862">While that may look OK to you, it's a syntax error as far as <tt class="backtick">[</tt> is concerned. The correct way to write this is: <span class="anchor" id="line-170"></span></li><li style="list-style-type:none"><span class="anchor" id="line-171"></span><span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><pre><span class="anchor" id="line-1-14"></span># POSIX
<span class="anchor" id="line-2-9"></span>[ "$foo" = bar ] # Right!</pre><span class="anchor" id="line-174"></span></li><li style="list-style-type:none"><p class="line862">This works fine on POSIX-conformant implementations even if <tt class="backtick">$foo</tt> begins with a <tt class="backtick">-</tt>, because POSIX <tt class="backtick">[</tt> determines its action depending on the number of arguments passed to it. Only very ancient shells have a problem with this, and you shouldn't worry about them when writing new code (see the <tt class="backtick">x"$foo"</tt> workaround below). <span class="anchor" id="line-175"></span><span class="anchor" id="line-176"></span></li></ul><p class="line862">In Bash and many other ksh-like shells, there is a superior alternative which uses the <a href="/BashFAQ/031">[[ keyword</a>. <span class="anchor" id="line-177"></span><span class="anchor" id="line-178"></span><p class="line867"><span class="anchor" id="line-179"></span><span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><pre><span class="anchor" id="line-1-15"></span># Bash / Ksh
<span class="anchor" id="line-2-10"></span>[[ $foo == bar ]] # Right!</pre><span class="anchor" id="line-182"></span><p class="line862">You don't need to quote variable references on the left-hand side of <tt class="backtick">=</tt> in <tt class="backtick">[[&nbsp;]]</tt> because they don't undergo word splitting or <a href="/glob">globbing</a>, and even blank variables will be handled correctly. On the other hand, quoting them won't hurt anything either. Unlike <tt class="backtick">[</tt> and <tt class="backtick">test</tt>, you may also use the identical <tt class="backtick">==</tt>. Do note however that comparisons using <tt class="backtick">[[</tt> perform pattern matching against the string on the right hand side, not just a plain string comparison. To make the string on the right literal, you must quote it if any characters that have special meaning in pattern matching contexts are used. <span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span><p class="line867"><span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span><pre><span class="anchor" id="line-1-16"></span># Bash / Ksh
<span class="anchor" id="line-2-11"></span>match=b*r
<span class="anchor" id="line-3-8"></span>[[ $foo == "$match" ]] # Good! Unquoted would also match against the pattern b*r.</pre><span class="anchor" id="line-189"></span><p class="line874">You may have seen code like this: <span class="anchor" id="line-190"></span><span class="anchor" id="line-191"></span><p class="line867"><span class="anchor" id="line-192"></span><span class="anchor" id="line-193"></span><span class="anchor" id="line-194"></span><pre><span class="anchor" id="line-1-17"></span># POSIX / Bourne
<span class="anchor" id="line-2-12"></span>[ x"$foo" = xbar ] # Ok, but usually unnecessary.</pre><span class="anchor" id="line-195"></span><p class="line862">The <tt class="backtick">x"$foo"</tt> hack is required for code that must run on <em>very</em> ancient shells which lack <a href="/BashFAQ/031">[[</a>, and have a more primitive <tt class="backtick">[</tt>, which gets confused if <tt class="backtick">$foo</tt> begins with a <tt class="backtick">-</tt>. On said older systems, <tt class="backtick">[</tt> still doesn't care whether the token on the right hand side of the <tt class="backtick">=</tt> begins with a <tt class="backtick">-</tt>. It just uses it literally. It's just the left-hand side that needs extra caution. <span class="anchor" id="line-196"></span><span class="anchor" id="line-197"></span><p class="line874">Note that shells that require this workaround are not POSIX-conforming. Even the Heirloom Bourne shell doesn't require this (probably the non-POSIX Bourne shell clone that's still most widely in use as a system shell). Such extreme portability is rarely a requirement and makes your code less readable (and uglier). <span class="anchor" id="line-198"></span><span class="anchor" id="line-199"></span><p class="line867"><span class="anchor" id="pf5"></span> <span class="anchor" id="line-200"></span><span class="anchor" id="line-201"></span><p class="line867">
<h2 id="cd_.24.28dirname_.22.24f.22.29">5. cd $(dirname "$f")</h2>
<span class="anchor" id="line-202"></span><p class="line862">This is yet another <a href="/Quotes">quoting</a> error. As with a variable expansion, the result of a <a href="/CommandSubstitution">CommandSubstitution</a> undergoes <a href="/WordSplitting">WordSplitting</a> and <a href="/glob">pathname expansion</a>. So you should quote it: <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line867"><span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><pre><span class="anchor" id="line-1-18"></span>cd -P -- "$(dirname -- "$f")"</pre><span class="anchor" id="line-207"></span><p class="line862">What's not obvious here is how the <a href="/Quotes">quotes</a> nest. A C programmer reading this would expect the first and second double-quotes to be grouped together; and then the third and fourth. But that's not the case in Bash. Bash treats the double-quotes <em>inside</em> the command substitution as one pair, and the double-quotes <em>outside</em> the substitution as another pair. <span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><p class="line874">Another way of writing this: the parser treats the command substitution as a "nesting level", and the quotes inside it are separate from the quotes outside it. <span class="anchor" id="line-210"></span><span class="anchor" id="line-211"></span><p class="line867"><span class="anchor" id="pf6"></span> <span class="anchor" id="line-212"></span><span class="anchor" id="line-213"></span><p class="line867">
<h2 id="A.5B_.22.24foo.22_.3D_bar_.26.26_.22.24bar.22_.3D_foo_.5D">6. [ "$foo" = bar &amp;&amp; "$bar" = foo ]</h2>
<span class="anchor" id="line-214"></span><p class="line862">You can't use <tt class="backtick">&amp;&amp;</tt> inside the <a href="/BashFAQ/031">old test (or [) command</a>. The Bash parser sees <tt class="backtick">&amp;&amp;</tt> outside of <tt class="backtick">[[&nbsp;]]</tt> or <tt class="backtick">((&nbsp;))</tt> and breaks your command into <em>two</em> commands, before and after the <tt class="backtick">&amp;&amp;</tt>. Use one of these instead: <span class="anchor" id="line-215"></span><span class="anchor" id="line-216"></span><p class="line867"><span class="anchor" id="line-217"></span><span class="anchor" id="line-218"></span><span class="anchor" id="line-219"></span><pre><span class="anchor" id="line-1-19"></span>[ bar = "$foo" ] &amp;&amp; [ foo = "$bar" ] # Right! (POSIX)
<span class="anchor" id="line-2-13"></span>[[ $foo = bar &amp;&amp; $bar = foo ]]       # Also right! (Bash / Ksh)</pre><span class="anchor" id="line-220"></span><p class="line862">(Note that we reversed the constant and the variable inside <tt class="backtick">[</tt> for the legacy reasons discussed in pitfall #4. We could also have reversed the <tt class="backtick">[[</tt> case, but the expansions would require quoting to prevent interpretation as a pattern.) The same thing applies to <tt class="backtick">||</tt>. Either use <tt class="backtick">[[</tt> instead, or use two <tt class="backtick">[</tt> commands. <span class="anchor" id="line-221"></span><span class="anchor" id="line-222"></span><p class="line874">Avoid this: <span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><p class="line867"><span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><pre><span class="anchor" id="line-1-20"></span>[ bar = "$foo" -a foo = "$bar" ] # Not portable.</pre><span class="anchor" id="line-227"></span><p class="line862">The binary <tt class="backtick">-a</tt> and <tt class="backtick">-o</tt>, and <tt class="backtick">(</tt> / <tt class="backtick">)</tt> (grouping) operators are XSI extensions to the POSIX standard. All are marked as obsolescent in POSIX-2008. They should not be used in new code. One of the practical problems with <tt class="backtick">[&nbsp;A&nbsp;=&nbsp;B&nbsp;-a&nbsp;C&nbsp;=&nbsp;D&nbsp;]</tt> (or <tt class="backtick">-o</tt>) is that <a class="http" href="http://www.opengroup.org/onlinepubs/9699919799/utilities/test.html">POSIX does not specify</a> the results of a <tt class="backtick">test</tt> or <tt class="backtick">[</tt> command with more than 4 arguments. It probably works in most shells, but you can't count on it. If you have to write for POSIX shells, then you should use two <tt class="backtick">test</tt> or <tt class="backtick">[</tt> commands separated by a <tt class="backtick">&amp;&amp;</tt> operator instead. <span class="anchor" id="line-228"></span><span class="anchor" id="line-229"></span><p class="line867"><span class="anchor" id="pf7"></span> <span class="anchor" id="line-230"></span><span class="anchor" id="line-231"></span><p class="line867">
<h2 id="A.5B.5B_.24foo_.3E_7_.5D.5D">7. [[ $foo &gt; 7 ]]</h2>
<span class="anchor" id="line-232"></span><p class="line862">There are multiple issues here. First, the <a href="/BashFAQ/031">[[ command</a> should <em>not</em> be used solely for evaluating <a href="/ArithmeticExpression">arithmetic expressions</a>. It should be used for test expressions involving one of the supported test operators. Though technically you <em>can</em> do math using some of <tt class="backtick">[[</tt>'s operators, it only makes sense to do so in conjunction with one of the non-math test operators somewhere in the expression. If you just want to do a numeric comparison (or any other shell arithmetic), it is much better to just use <tt class="backtick">((&nbsp;))</tt> instead: <span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span><p class="line867"><span class="anchor" id="line-235"></span><span class="anchor" id="line-236"></span><span class="anchor" id="line-237"></span><span class="anchor" id="line-238"></span><pre><span class="anchor" id="line-1-21"></span># Bash / Ksh
<span class="anchor" id="line-2-14"></span>((foo &gt; 7))     # Right!
<span class="anchor" id="line-3-9"></span>[[ foo -gt 7 ]] # Works, but is pointless. Most will consider it wrong. Use ((...)) or let instead.</pre><span class="anchor" id="line-239"></span><p class="line862">If you use the <tt class="backtick">&gt;</tt> operator inside <tt class="backtick">[[&nbsp;]]</tt>, it's treated as a string comparison (test for collation order by locale), <em>not</em> an integer comparison. This may work sometimes, but it will fail when you least expect it. If you use <tt class="backtick">&gt;</tt> inside <tt class="backtick">[&nbsp;]</tt>, it's even worse: it's an output redirection. You'll get a file named <tt class="backtick">7</tt> in your directory, and the test will succeed as long as <tt class="backtick">$foo</tt> is not empty. <span class="anchor" id="line-240"></span><span class="anchor" id="line-241"></span><p class="line862">If strict POSIX-conformance is a requirement, and <tt class="backtick">((</tt> is not available, then the correct alternative using old-style <tt class="backtick">[</tt> is <span class="anchor" id="line-242"></span><span class="anchor" id="line-243"></span><p class="line867"><span class="anchor" id="line-244"></span><span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><span class="anchor" id="line-247"></span><pre><span class="anchor" id="line-1-22"></span># POSIX
<span class="anchor" id="line-2-15"></span>[ "$foo" -gt 7 ]       # Also right!
<span class="anchor" id="line-3-10"></span>[ $((foo &gt; 7)) -ne 0 ] # POSIX-compatible equivalent to ((, for more general math operations.</pre><span class="anchor" id="line-248"></span><p class="line862">Note that the <tt class="backtick">test&nbsp;...&nbsp;-gt</tt> command will fail in interesting ways if <tt class="backtick">$foo</tt> is <a href="/BashFAQ/054">not an integer</a>. Therefore, there's not much point in quoting it properly other than for performance and to confine the arguments to a single word to reduce the likelihood of obscure side-effects possible in some shells. <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line862">If the input to any arithmetic context (including <tt class="backtick">((</tt> or <tt class="backtick">let</tt>), or <tt class="backtick">[</tt> test expression involving numeric comparisons can't be guaranteed then you must <em>always</em> <a href="/BashFAQ/054">validate your input before evaluating the expression</a>. <span class="anchor" id="line-251"></span><span class="anchor" id="line-252"></span><p class="line867"><span class="anchor" id="line-253"></span><span class="anchor" id="line-254"></span><span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span><span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><pre><span class="anchor" id="line-1-23"></span># POSIX
<span class="anchor" id="line-2-16"></span>case $foo in
<span class="anchor" id="line-3-11"></span>    *[![:digit:]]*)
<span class="anchor" id="line-4-6"></span>        printf '$foo expanded to a non-digit: %s\n' "$foo" &gt;&amp;2
<span class="anchor" id="line-5-3"></span>        exit 1
<span class="anchor" id="line-6-1"></span>        ;;
<span class="anchor" id="line-7-1"></span>    *)
<span class="anchor" id="line-8-1"></span>        [ $foo -gt 7 ]
<span class="anchor" id="line-9-1"></span>esac</pre><span class="anchor" id="line-263"></span><p class="line867"><span class="anchor" id="pf8"></span> <span class="anchor" id="line-264"></span><span class="anchor" id="line-265"></span><p class="line867">
<h2 id="grep_foo_bar_.7C_while_read_-r.3B_do_.28.28count.2B-.2B-.29.29.3B_done">8. grep foo bar | while read -r; do ((count++)); done</h2>
<span class="anchor" id="line-266"></span><p class="line862">The code above looks OK at first glance, doesn't it? Sure, it's just a poor implementation of <tt class="backtick">grep&nbsp;-c</tt>, but it's intended as a simplistic example. Changes to <tt class="backtick">count</tt> won't propagate outside the <tt class="backtick">while</tt> loop because each command in a pipeline is executed in a separate <a href="/SubShell">SubShell</a>. This surprises almost every Bash beginner at some point. <span class="anchor" id="line-267"></span><span class="anchor" id="line-268"></span><p class="line862">POSIX doesn't specify whether or not the last element of a pipeline is evaluated in a subshell. Some shells such as ksh93 and Bash &gt;= 4.2 with <tt class="backtick">shopt&nbsp;-s&nbsp;lastpipe</tt> enabled will run the <tt class="backtick">while</tt> loop in this example in the original shell process, allowing any side-effects within to take effect. Therefore, portable scripts must be written in such a way as to not depend upon either behavior. <span class="anchor" id="line-269"></span><span class="anchor" id="line-270"></span><p class="line862">For workarounds for this and similar issues, please see <a href="/BashFAQ/024">Bash FAQ #24</a>. It's a bit too long to fit here. <span class="anchor" id="line-271"></span><span class="anchor" id="line-272"></span><p class="line867"><span class="anchor" id="pf9"></span> <span class="anchor" id="line-273"></span><span class="anchor" id="line-274"></span><p class="line867">
<h2 id="if_.5Bgrep_foo_myfile.5D">9. if [grep foo myfile]</h2>
<span class="anchor" id="line-275"></span><p class="line862">Many beginners have an incorrect intuition about <tt class="backtick">if</tt> statements brought about by seeing the very common pattern of an <tt class="backtick">if</tt> keyword followed immediately by a <tt class="backtick">[</tt> or <tt class="backtick">[[</tt>. This convinces people that the <tt class="backtick">[</tt> is somehow part of the <tt class="backtick">if</tt> statement's syntax, just like parentheses used in C's <tt class="backtick">if</tt> statement. <span class="anchor" id="line-276"></span><span class="anchor" id="line-277"></span><p class="line862">This is <em>not</em> the case! <tt class="backtick">if</tt> takes a <em>command</em>. <tt class="backtick">[</tt> is a command, not a syntax marker for the <tt class="backtick">if</tt> statement. It's equivalent to the <tt class="backtick">test</tt> command, except that the final argument must be a <tt class="backtick">]</tt>. For example: <span class="anchor" id="line-278"></span><span class="anchor" id="line-279"></span><p class="line867"><span class="anchor" id="line-280"></span><span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><span class="anchor" id="line-283"></span><pre><span class="anchor" id="line-1-24"></span># POSIX
<span class="anchor" id="line-2-17"></span>if [ false ]; then echo "HELP"; fi
<span class="anchor" id="line-3-12"></span>if test false; then echo "HELP"; fi</pre><span class="anchor" id="line-284"></span><p class="line874">are equivalent -- both checking that the argument "false" is non-empty. In both cases HELP will always be printed, to the surprise of programmers from other languages guessing about shell syntax. <span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><p class="line862">The syntax of an <tt class="backtick">if</tt> statement is: <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><p class="line867"><span class="anchor" id="line-289"></span><span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><span class="anchor" id="line-295"></span><pre><span class="anchor" id="line-1-25"></span>if COMMANDS
<span class="anchor" id="line-2-18"></span>then &lt;COMMANDS&gt;
<span class="anchor" id="line-3-13"></span>elif &lt;COMMANDS&gt; # optional
<span class="anchor" id="line-4-7"></span>then &lt;COMMANDS&gt;
<span class="anchor" id="line-5-4"></span>else &lt;COMMANDS&gt; # optional
<span class="anchor" id="line-6-2"></span>fi # required</pre><span class="anchor" id="line-296"></span><p class="line862">Once again, <tt class="backtick">[</tt> is a command. It takes arguments like any other regular <em>simple command</em>. <tt class="backtick">if</tt> is a <em>compound command</em> which contains other commands -- and <strong>there is no [</strong> in its syntax! <span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span><p class="line862">While bash has a builtin command <tt class="backtick">[</tt> and thus <tt class="backtick">knows</tt> about <tt class="backtick">[</tt> it has nothing special to do with <tt class="backtick">]</tt>. Bash only passes <tt class="backtick">]</tt> as argument to the <tt class="backtick">[</tt> command, which requires <tt class="backtick">]</tt> to be the last argument only to make scripts look better. <span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span><p class="line862">There may be zero or more optional <tt class="backtick">elif</tt> sections, and one optional <tt class="backtick">else</tt> section. <span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span><p class="line862">The <tt class="backtick">if</tt> compound command is made up of two or more sections containing <em>lists</em> of commands, each delimited by a <tt class="backtick">then</tt>, <tt class="backtick">elif</tt>, or <tt class="backtick">else</tt> keyword, and is terminated by the <tt class="backtick">fi</tt> keyword. The exit status of the final command of the first section and each subsequent <tt class="backtick">elif</tt> section determines whether each corresponding <tt class="backtick">then</tt> section is evaluated. Another <tt class="backtick">elif</tt> is evaluated until one of the <tt class="backtick">then</tt> sections is executed. If no <tt class="backtick">then</tt> section is evaluated, then the <tt class="backtick">else</tt> branch is taken, or if no <tt class="backtick">else</tt> is given, the <tt class="backtick">if</tt> block is complete and the overall <tt class="backtick">if</tt> command returns 0 (true). <span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><p class="line862">If you want to make a decision based on the output of a <tt class="backtick">grep</tt> command, you do <em>not</em> want to enclose it in parentheses, brackets, backticks, or <em>any other</em> syntax! Just use <tt class="backtick">grep</tt> as the <tt class="backtick">COMMANDS</tt> after the <tt class="backtick">if</tt>, like this: <span class="anchor" id="line-305"></span><span class="anchor" id="line-306"></span><p class="line867"><span class="anchor" id="line-307"></span><span class="anchor" id="line-308"></span><span class="anchor" id="line-309"></span><span class="anchor" id="line-310"></span><pre><span class="anchor" id="line-1-26"></span>if grep -q fooregex myfile; then
<span class="anchor" id="line-2-19"></span>...
<span class="anchor" id="line-3-14"></span>fi</pre><span class="anchor" id="line-311"></span><p class="line862">If the <tt class="backtick">grep</tt> matches a line from <tt class="backtick">myfile</tt>, then the exit code will be 0 (true), and the <tt class="backtick">then</tt> part will be executed. Otherwise, if there are no matches, <tt class="backtick">grep</tt> will return non-zero and the overall <tt class="backtick">if</tt> command will be zero. <span class="anchor" id="line-312"></span><span class="anchor" id="line-313"></span><p class="line867"><strong>See also:</strong> <span class="anchor" id="line-314"></span><span class="anchor" id="line-315"></span><ul><li><p class="line891"><a href="/BashGuide/TestsAndConditionals">BashGuide/TestsAndConditionals</a> <span class="anchor" id="line-316"></span></li><li><p class="line891"><a class="http" href="http://wiki.bash-hackers.org/syntax/ccmd/if_clause">http://wiki.bash-hackers.org/syntax/ccmd/if_clause</a> <span class="anchor" id="line-317"></span><span class="anchor" id="line-318"></span></li></ul><p class="line867"><span class="anchor" id="pf10"></span> <span class="anchor" id="line-319"></span><span class="anchor" id="line-320"></span><p class="line867">
<h2 id="if_.5Bbar.3D.22.24foo.22.5D.3B_then_...">10. if [bar="$foo"]; then ...</h2>
<span class="anchor" id="line-321"></span><p class="line867"><span class="anchor" id="line-322"></span><span class="anchor" id="line-323"></span><span class="anchor" id="line-324"></span><span class="anchor" id="line-325"></span><span class="anchor" id="line-326"></span><span class="anchor" id="line-327"></span><span class="anchor" id="line-328"></span><pre><span class="anchor" id="line-1-27"></span>[bar="$foo"]     # Wrong!
<span class="anchor" id="line-2-20"></span>[ bar="$foo" ]   # Still wrong!
<span class="anchor" id="line-3-15"></span>[bar = "$foo"]   # Also wrong!
<span class="anchor" id="line-4-8"></span>[[bar="$foo"]]   # Wrong again!
<span class="anchor" id="line-5-5"></span>[[ bar="$foo" ]] # Guess what?  Wrong!
<span class="anchor" id="line-6-3"></span>[[bar = "$foo"]] # Do I really need to say it....</pre><span class="anchor" id="line-329"></span><span class="anchor" id="line-330"></span><p class="line862">As explained in the previous example, <tt class="backtick">[</tt> is a command (which can be proven with <tt class="backtick">type&nbsp;-t&nbsp;[</tt> or <tt class="backtick">whence&nbsp;-v&nbsp;[</tt>). Just like with any other simple command, Bash expects the command to be followed by a space, then the first argument, then another space, etc. You can't just run things all together without putting the spaces in! Here are the correct ways: <span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span><p class="line867"><span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><span class="anchor" id="line-335"></span><span class="anchor" id="line-336"></span><pre><span class="anchor" id="line-1-28"></span>if [ bar = "$foo" ]; then ...
<span class="anchor" id="line-2-21"></span>
<span class="anchor" id="line-3-16"></span>if [[ bar = "$foo" ]]; then ...</pre><span class="anchor" id="line-337"></span><span class="anchor" id="line-338"></span><p class="line862">In the first form, <tt class="backtick">[</tt> is the command name, and <tt class="backtick">bar</tt>, <tt class="backtick">=</tt>, the expansion of <tt class="backtick">"$foo"</tt>, and <tt class="backtick">]</tt> are separate <a href="/Arguments">arguments</a> to it. There must be whitespace between each pair of arguments, so the shell knows where each argument begins and ends.  The second form is similar, except that <tt class="backtick">[[</tt> is a special keyword, which is terminated by the <tt class="backtick">]]</tt>.  For more details on the difference between the two, see <a href="/BashFAQ/031">Bash FAQ 31</a>. <span class="anchor" id="line-339"></span><span class="anchor" id="line-340"></span><p class="line867"><span class="anchor" id="pf11"></span> <span class="anchor" id="line-341"></span><span class="anchor" id="line-342"></span><p class="line867">
<h2 id="if_.5B_.5B_a_.3D_b_.5D_.26.26_.5B_c_.3D_d_.5D_.5D.3B_then_...">11. if [ [ a = b ] &amp;&amp; [ c = d ] ]; then ...</h2>
<span class="anchor" id="line-343"></span><p class="line862">Here we go again. <tt class="backtick">[</tt> is a <em>command</em>. It is not a syntactic marker that sits between <tt class="backtick">if</tt> and some sort of C-like "condition". Nor is it used for grouping. You cannot take C-like <tt class="backtick">if</tt> commands and translate them into Bash commands just by replacing parentheses with square brackets! <span class="anchor" id="line-344"></span><span class="anchor" id="line-345"></span><p class="line874">If you want to express a compound conditional, do this: <span class="anchor" id="line-346"></span><span class="anchor" id="line-347"></span><p class="line867"><span class="anchor" id="line-348"></span><span class="anchor" id="line-349"></span><pre><span class="anchor" id="line-1-29"></span>if [ a = b ] &amp;&amp; [ c = d ]; then ...</pre><span class="anchor" id="line-350"></span><p class="line862">Note that here we have two <em>commands</em> after the <tt class="backtick">if</tt>, joined by an <tt class="backtick">&amp;&amp;</tt> (logical AND, shortcut evaluation) operator. It's precisely the same as: <span class="anchor" id="line-351"></span><span class="anchor" id="line-352"></span><p class="line867"><span class="anchor" id="line-353"></span><span class="anchor" id="line-354"></span><pre><span class="anchor" id="line-1-30"></span>if test a = b &amp;&amp; test c = d; then ...</pre><span class="anchor" id="line-355"></span><p class="line862">If the first <tt class="backtick">test</tt> command returns false, the body of the <tt class="backtick">if</tt> statement is not entered. If it returns true, then the second <tt class="backtick">test</tt> command is run; and if that also one returns true, then the body of the <tt class="backtick">if</tt> statement <em>will</em> be entered.  (C programmers are already familiar with <tt class="backtick">&amp;&amp;</tt>.  Bash uses the same <em>short-circuit evaluation</em>.  Likewise <tt class="backtick">||</tt> does short-circuit evaluation for the <em>OR</em> operation.) <span class="anchor" id="line-356"></span><span class="anchor" id="line-357"></span><p class="line862">The <a href="/BashFAQ/031">[[ keyword</a> <em>does</em> permit the use of <tt class="backtick">&amp;&amp;</tt>, so it could also be written this way: <span class="anchor" id="line-358"></span><span class="anchor" id="line-359"></span><p class="line867"><span class="anchor" id="line-360"></span><span class="anchor" id="line-361"></span><pre><span class="anchor" id="line-1-31"></span>if [[ a = b &amp;&amp; c = d ]]; then ...</pre><span class="anchor" id="line-362"></span><p class="line862">See <a href="/BashPitfalls#pf6">pitfall #6</a> for a pitfall related to <em>tests</em> combined with conditional operators. <span class="anchor" id="line-363"></span><span class="anchor" id="line-364"></span><p class="line867"><span class="anchor" id="pf12"></span> <span class="anchor" id="line-365"></span><span class="anchor" id="line-366"></span><p class="line867">
<h2 id="read_.24foo">12. read $foo</h2>
<span class="anchor" id="line-367"></span><p class="line862">You don't use a <tt class="backtick">$</tt> before the variable name in a <tt class="backtick">read</tt> command.  If you want to put data into the variable named <tt class="backtick">foo</tt>, you do it like this: <span class="anchor" id="line-368"></span><span class="anchor" id="line-369"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-370"></span><span class="anchor" id="line-371"></span><pre><span class="anchor" id="line-1-32"></span> read foo</pre><span class="anchor" id="line-372"></span><span class="anchor" id="line-373"></span></li></ul><p class="line874">Or more safely: <span class="anchor" id="line-374"></span><span class="anchor" id="line-375"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><pre><span class="anchor" id="line-1-33"></span> IFS= read -r foo</pre><span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span></li></ul><p class="line867"><tt class="backtick">read&nbsp;$foo</tt> would read a line of input and put it in the variable(s) whose name(s) are in <tt class="backtick">$foo</tt>.  This might be useful if you actually intended <tt class="backtick">foo</tt> to be a <a href="/BashFAQ/006">reference</a> to some other variable; but in the majority of cases, this is simply a bug. <span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><p class="line867"><span class="anchor" id="pf13"></span> <span class="anchor" id="line-382"></span><span class="anchor" id="line-383"></span><p class="line867">
<h2 id="cat_file_.7C_sed_s.2Ffoo.2Fbar.2F_.3E_file">13. cat file | sed s/foo/bar/ &gt; file</h2>
<span class="anchor" id="line-384"></span><p class="line862">You <strong>cannot</strong> read from a file and write to it in the same pipeline. Depending on what your pipeline does, the file may be clobbered (to 0 bytes, or possibly to a number of bytes equal to the size of your operating system's pipeline buffer), or it may grow until it fills the available disk space, or reaches your operating system's file size limitation, or your quota, etc. <span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><p class="line874">If you want to make a change to a file safely, other than appending to the end of it, use a text editor. <span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-389"></span><span class="anchor" id="line-390"></span><pre><span class="anchor" id="line-1-34"></span> printf %s\\n ',s/foo/bar/g' w q | ed -s file</pre><span class="anchor" id="line-391"></span><span class="anchor" id="line-392"></span></li></ul><p class="line862">If you are doing something that cannot be done with a text editor there <em>must</em> be a temporary file created at some point(*). For example, the following is completely portable: <span class="anchor" id="line-393"></span><span class="anchor" id="line-394"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-395"></span><span class="anchor" id="line-396"></span><pre><span class="anchor" id="line-1-35"></span> sed 's/foo/bar/g' file &gt; tmpfile &amp;&amp; mv tmpfile file</pre><span class="anchor" id="line-397"></span><span class="anchor" id="line-398"></span></li></ul><p class="line862">The following will <em>only</em> work on GNU sed 4.x: <span class="anchor" id="line-399"></span><span class="anchor" id="line-400"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-401"></span><span class="anchor" id="line-402"></span><pre><span class="anchor" id="line-1-36"></span> sed -i 's/foo/bar/g' file(s)</pre><span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span></li></ul><p class="line874">Note that this also creates a temporary file, and does the same sort of renaming trickery -- it just handles it transparently. <span class="anchor" id="line-405"></span><span class="anchor" id="line-406"></span><p class="line874">And the following equivalent command requires perl 5.x: <span class="anchor" id="line-407"></span><span class="anchor" id="line-408"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span><pre><span class="anchor" id="line-1-37"></span> perl -pi -e 's/foo/bar/g' file(s)</pre><span class="anchor" id="line-411"></span><span class="anchor" id="line-412"></span></li></ul><p class="line862">For more details on replacing contents of files, please see <a href="/BashFAQ/021">Bash FAQ #21</a>. <span class="anchor" id="line-413"></span><span class="anchor" id="line-414"></span><p class="line862">(*) <tt class="backtick">sponge</tt> from <a class="http" href="http://packages.debian.org/sid/moreutils">moreutils</a> uses this example in its manual: <span class="anchor" id="line-415"></span><span class="anchor" id="line-416"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-417"></span><span class="anchor" id="line-418"></span><pre><span class="anchor" id="line-1-38"></span> sed '...' file | grep '...' | sponge file</pre><span class="anchor" id="line-419"></span><span class="anchor" id="line-420"></span></li></ul><p class="line862">Rather than using a temporary file plus an atomic <tt class="backtick">mv</tt>, this version "soaks up" (the actual description in the manual!) all the data, before opening and writing to the <tt class="backtick">file</tt>.  This version will cause data loss if the program or system crashes during the write operation, because there's no copy of the original file on disk at that point. <span class="anchor" id="line-421"></span><span class="anchor" id="line-422"></span><p class="line862">Using a temporary file + <tt class="backtick">mv</tt> still incurs a slight risk of data loss in case of a system crash / power loss; to be 100% certain that either the old or the new file will survive a power loss, you must use <tt class="backtick">sync</tt> before the <tt class="backtick">mv</tt>. <span class="anchor" id="line-423"></span><span class="anchor" id="line-424"></span><p class="line867"><span class="anchor" id="pf14"></span> <span class="anchor" id="line-425"></span><span class="anchor" id="line-426"></span><p class="line867">
<h2 id="echo_.24foo">14. echo $foo</h2>
<span class="anchor" id="line-427"></span><p class="line862">This relatively innocent-looking command causes <em>massive</em> confusion. Because the <tt class="backtick">$foo</tt> isn't <a href="/Quotes">quoted</a>, it will not only be subject to <a href="/WordSplitting">WordSplitting</a>, but also file <a href="/glob">globbing</a>. This misleads Bash programmers into thinking their variables <em>contain</em> the wrong values, when in fact the variables are OK -- it's just the word splitting or filename expansion that's messing up their view of what's happening. <span class="anchor" id="line-428"></span><span class="anchor" id="line-429"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-430"></span><span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span><pre><span class="anchor" id="line-1-39"></span> msg="Please enter a file name of the form *.zip"
<span class="anchor" id="line-2-22"></span> echo $msg</pre><span class="anchor" id="line-433"></span><span class="anchor" id="line-434"></span></li></ul><p class="line874">This message is split into words and any globs are expanded, such as the *.zip. What will your users think when they see this message: <span class="anchor" id="line-435"></span><span class="anchor" id="line-436"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-437"></span><span class="anchor" id="line-438"></span><pre><span class="anchor" id="line-1-40"></span> Please enter a file name of the form freenfss.zip lw35nfss.zip</pre><span class="anchor" id="line-439"></span><span class="anchor" id="line-440"></span></li></ul><p class="line874">To demonstrate: <span class="anchor" id="line-441"></span><span class="anchor" id="line-442"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-443"></span><span class="anchor" id="line-444"></span><span class="anchor" id="line-445"></span><span class="anchor" id="line-446"></span><pre><span class="anchor" id="line-1-41"></span> var="*.zip"   # var contains an asterisk, a period, and the word "zip"
<span class="anchor" id="line-2-23"></span> echo "$var"   # writes *.zip
<span class="anchor" id="line-3-17"></span> echo $var     # writes the list of files which end with .zip</pre><span class="anchor" id="line-447"></span><span class="anchor" id="line-448"></span></li></ul><p class="line862">In fact, the <tt class="backtick">echo</tt> command cannot be used with absolute safety here. If the variable contains <tt class="backtick">-n</tt> for example, <tt class="backtick">echo</tt> will consider that an option, rather than data to be printed. The only absolutely <em>sure</em> way to print the value of a variable is using <tt class="backtick">printf</tt>: <span class="anchor" id="line-449"></span><span class="anchor" id="line-450"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-451"></span><span class="anchor" id="line-452"></span><pre><span class="anchor" id="line-1-42"></span> printf "%s\n" "$foo"</pre><span class="anchor" id="line-453"></span><span class="anchor" id="line-454"></span></li></ul><p class="line867"><span class="anchor" id="pf15"></span> <span class="anchor" id="line-455"></span><span class="anchor" id="line-456"></span><p class="line867">
<h2 id="A.24foo.3Dbar">15. $foo=bar</h2>
<span class="anchor" id="line-457"></span><p class="line862">No, you don't assign a variable by putting a <tt class="backtick">$</tt> in front of the variable name. This isn't perl. <span class="anchor" id="line-458"></span><span class="anchor" id="line-459"></span><p class="line867"><span class="anchor" id="pf16"></span> <span class="anchor" id="line-460"></span><span class="anchor" id="line-461"></span><p class="line867">
<h2 id="foo_.3D_bar">16. foo = bar</h2>
<span class="anchor" id="line-462"></span><p class="line862">No, you can't put spaces around the <tt class="backtick">=</tt> when assigning to a variable. This isn't C. When you write <tt class="backtick">foo&nbsp;=&nbsp;bar</tt> the shell splits it into three words. The first word, <tt class="backtick">foo</tt>, is taken as the command name. The second and third become the arguments to that command. <span class="anchor" id="line-463"></span><span class="anchor" id="line-464"></span><p class="line874">Likewise, the following are also wrong: <span class="anchor" id="line-465"></span><span class="anchor" id="line-466"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-467"></span><span class="anchor" id="line-468"></span><span class="anchor" id="line-469"></span><span class="anchor" id="line-470"></span><span class="anchor" id="line-471"></span><span class="anchor" id="line-472"></span><span class="anchor" id="line-473"></span><pre><span class="anchor" id="line-1-43"></span> foo= bar    # WRONG!
<span class="anchor" id="line-2-24"></span> foo =bar    # WRONG!
<span class="anchor" id="line-3-18"></span> $foo = bar; # COMPLETELY WRONG!
<span class="anchor" id="line-4-9"></span>
<span class="anchor" id="line-5-6"></span> foo=bar     # Right.
<span class="anchor" id="line-6-4"></span> foo="bar"   # More Right.</pre><span class="anchor" id="line-474"></span><span class="anchor" id="line-475"></span></li></ul><p class="line867"><span class="anchor" id="pf17"></span> <span class="anchor" id="line-476"></span><span class="anchor" id="line-477"></span><p class="line867">
<h2 id="echo_.3C.3CEOF">17. echo &lt;&lt;EOF</h2>
<span class="anchor" id="line-478"></span><p class="line862">A here document is a useful tool for embedding large blocks of textual data in a script. It causes a redirection of the lines of text in the script to the standard input of a command. Unfortunately, <tt class="backtick">echo</tt> is not a command which reads from stdin. <span class="anchor" id="line-479"></span><span class="anchor" id="line-480"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-481"></span><span class="anchor" id="line-482"></span><span class="anchor" id="line-483"></span><span class="anchor" id="line-484"></span><span class="anchor" id="line-485"></span><span class="anchor" id="line-486"></span><span class="anchor" id="line-487"></span><span class="anchor" id="line-488"></span><span class="anchor" id="line-489"></span><span class="anchor" id="line-490"></span><span class="anchor" id="line-491"></span><span class="anchor" id="line-492"></span><span class="anchor" id="line-493"></span><span class="anchor" id="line-494"></span><span class="anchor" id="line-495"></span><span class="anchor" id="line-496"></span><pre><span class="anchor" id="line-1-44"></span>  # This is wrong:
<span class="anchor" id="line-2-25"></span>  echo &lt;&lt;EOF
<span class="anchor" id="line-3-19"></span>  Hello world
<span class="anchor" id="line-4-10"></span>  How's it going?
<span class="anchor" id="line-5-7"></span>  EOF
<span class="anchor" id="line-6-5"></span>
<span class="anchor" id="line-7-2"></span>  # This is what you were trying to do:
<span class="anchor" id="line-8-2"></span>  cat &lt;&lt;EOF
<span class="anchor" id="line-9-2"></span>  Hello world
<span class="anchor" id="line-10-1"></span>  How's it going?
<span class="anchor" id="line-11-1"></span>  EOF
<span class="anchor" id="line-12-1"></span>
<span class="anchor" id="line-13"></span>  # Or, use quotes which can span multiple lines (efficient, echo is built-in):
<span class="anchor" id="line-14"></span>  echo "Hello world
<span class="anchor" id="line-15"></span>  How's it going?"</pre><span class="anchor" id="line-497"></span><span class="anchor" id="line-498"></span></li></ul><p class="line862">Using quotes like that is fine -- it works great, in all shells -- but it doesn't let you just drop a block of lines into the script.  There's syntactic markup on the first and last line.  If you want to have your lines untouched by shell syntax, and don't want to spawn a <tt class="backtick">cat</tt> command, here's another alternative: <span class="anchor" id="line-499"></span><span class="anchor" id="line-500"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-501"></span><span class="anchor" id="line-502"></span><span class="anchor" id="line-503"></span><span class="anchor" id="line-504"></span><span class="anchor" id="line-505"></span><span class="anchor" id="line-506"></span><pre><span class="anchor" id="line-1-45"></span>  # Or use printf (also efficient, printf is built-in):
<span class="anchor" id="line-2-26"></span>  printf %s "\
<span class="anchor" id="line-3-20"></span>  Hello world
<span class="anchor" id="line-4-11"></span>  How's it going?
<span class="anchor" id="line-5-8"></span>  "</pre><span class="anchor" id="line-507"></span><span class="anchor" id="line-508"></span></li></ul><p class="line862">In the <tt class="backtick">printf</tt> example, the <tt class="backtick">\</tt> on the first line prevents an extra newline at the beginning of the text block.  There's a literal newline at the end (because the final quote is on a new line).  The lack of <tt class="backtick">\n</tt> in the printf format argument prevents <tt class="backtick">printf</tt> adding an extra newline at the end.  The <tt class="backtick">\</tt> trick won't work in single quotes.  If you need/want single quotes around the block of text, you have two choices, both of which necessitate shell syntax "contaminating" your data: <span class="anchor" id="line-509"></span><span class="anchor" id="line-510"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-511"></span><span class="anchor" id="line-512"></span><span class="anchor" id="line-513"></span><span class="anchor" id="line-514"></span><span class="anchor" id="line-515"></span><span class="anchor" id="line-516"></span><span class="anchor" id="line-517"></span><pre><span class="anchor" id="line-1-46"></span>  printf %s \
<span class="anchor" id="line-2-27"></span>  'Hello world
<span class="anchor" id="line-3-21"></span>  '
<span class="anchor" id="line-4-12"></span>
<span class="anchor" id="line-5-9"></span>  printf %s 'Hello world
<span class="anchor" id="line-6-6"></span>  '</pre><span class="anchor" id="line-518"></span><span class="anchor" id="line-519"></span></li></ul><p class="line867"><span class="anchor" id="pf18"></span> <span class="anchor" id="line-520"></span><span class="anchor" id="line-521"></span><p class="line867">
<h2 id="su_-c_.27some_command.27">18. su -c 'some command'</h2>
<span class="anchor" id="line-522"></span><p class="line862">This syntax is <em>almost</em> correct. The problem is, on many platforms, <tt class="backtick">su</tt> takes a <tt class="backtick">-c</tt> argument, but it's not the one you want. For example, on OpenBSD: <span class="anchor" id="line-523"></span><span class="anchor" id="line-524"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-525"></span><span class="anchor" id="line-526"></span><span class="anchor" id="line-527"></span><pre><span class="anchor" id="line-1-47"></span> $ su -c 'echo hello'
<span class="anchor" id="line-2-28"></span> su: only the superuser may specify a login class</pre><span class="anchor" id="line-528"></span><span class="anchor" id="line-529"></span></li></ul><p class="line862">You want to pass <tt class="backtick">-c&nbsp;'some&nbsp;command'</tt> to a shell, which means you need a username before the <tt class="backtick">-c</tt>. <span class="anchor" id="line-530"></span><span class="anchor" id="line-531"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-532"></span><span class="anchor" id="line-533"></span><pre><span class="anchor" id="line-1-48"></span> su root -c 'some command' # Now it's right.</pre><span class="anchor" id="line-534"></span><span class="anchor" id="line-535"></span></li></ul><p class="line867"><tt class="backtick">su</tt> assumes a username of root when you omit one, but this falls on its face when you want to pass a command to the shell afterward. You must supply the username in this case. <span class="anchor" id="line-536"></span><span class="anchor" id="line-537"></span><p class="line867"><span class="anchor" id="pf19"></span> <span class="anchor" id="line-538"></span><span class="anchor" id="line-539"></span><p class="line867">
<h2 id="cd_.2Ffoo.3B_bar">19. cd /foo; bar</h2>
<span class="anchor" id="line-540"></span><p class="line862">If you don't check for errors from the <tt class="backtick">cd</tt> command, you might end up executing <tt class="backtick">bar</tt> in the wrong place. This could be a major disaster, if for example <tt class="backtick">bar</tt> happens to be <tt class="backtick">rm&nbsp;-f&nbsp;*</tt>. <span class="anchor" id="line-541"></span><span class="anchor" id="line-542"></span><p class="line862">You must <strong>always</strong> check for errors from a <tt class="backtick">cd</tt> command. The simplest way to do that is: <span class="anchor" id="line-543"></span><span class="anchor" id="line-544"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-545"></span><span class="anchor" id="line-546"></span><pre><span class="anchor" id="line-1-49"></span> cd /foo &amp;&amp; bar</pre><span class="anchor" id="line-547"></span><span class="anchor" id="line-548"></span></li></ul><p class="line862">If there's more than just one command after the <tt class="backtick">cd</tt>, you might prefer this: <span class="anchor" id="line-549"></span><span class="anchor" id="line-550"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-551"></span><span class="anchor" id="line-552"></span><span class="anchor" id="line-553"></span><span class="anchor" id="line-554"></span><span class="anchor" id="line-555"></span><pre><span class="anchor" id="line-1-50"></span> cd /foo || exit 1
<span class="anchor" id="line-2-29"></span> bar
<span class="anchor" id="line-3-22"></span> baz
<span class="anchor" id="line-4-13"></span> bat ... # Lots of commands.</pre><span class="anchor" id="line-556"></span><span class="anchor" id="line-557"></span></li></ul><p class="line867"><tt class="backtick">cd</tt> will report the failure to change directories, with a stderr message such as "bash: cd: /foo: No such file or directory". If you want to add your own message in stdout, however, you could use command grouping: <span class="anchor" id="line-558"></span><span class="anchor" id="line-559"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-560"></span><span class="anchor" id="line-561"></span><span class="anchor" id="line-562"></span><span class="anchor" id="line-563"></span><pre><span class="anchor" id="line-1-51"></span> cd /net || { echo &gt;&amp;2 "Can't read /net. Make sure you've logged in to the Samba network, and try again."; exit 1; }
<span class="anchor" id="line-2-30"></span> do_stuff
<span class="anchor" id="line-3-23"></span> more_stuff</pre><span class="anchor" id="line-564"></span><span class="anchor" id="line-565"></span></li></ul><p class="line862">Note there's a required space between <tt class="backtick">{</tt> and <tt class="backtick">echo</tt>, and a required <tt class="backtick">;</tt> before the closing <tt class="backtick">}</tt>.  You could also write a <tt class="backtick">die</tt> function, if you prefer. <span class="anchor" id="line-566"></span><span class="anchor" id="line-567"></span><p class="line862">Some people also like to enable <a href="/BashFAQ/105">set -e</a> to make their scripts abort on <em>any</em> command that returns non-zero, but this can be <a href="/BashFAQ/105">rather tricky to use correctly</a> (since many common commands may return a non-zero for a warning condition, which you may not want to treat as fatal). <span class="anchor" id="line-568"></span><span class="anchor" id="line-569"></span><p class="line862">By the way, if you're changing directories a lot in a Bash script, be sure to read the Bash help on <tt class="backtick">pushd</tt>, <tt class="backtick">popd</tt>, and <tt class="backtick">dirs</tt>. Perhaps all that code you wrote to manage <tt class="backtick">cd</tt>'s and <tt class="backtick">pwd</tt>'s is completely unnecessary. <span class="anchor" id="line-570"></span><span class="anchor" id="line-571"></span><p class="line874">Speaking of which, compare this: <span class="anchor" id="line-572"></span><span class="anchor" id="line-573"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-574"></span><span class="anchor" id="line-575"></span><span class="anchor" id="line-576"></span><span class="anchor" id="line-577"></span><span class="anchor" id="line-578"></span><span class="anchor" id="line-579"></span><pre><span class="anchor" id="line-1-52"></span> find ... -type d -print0 | while IFS= read -r -d '' subdir; do
<span class="anchor" id="line-2-31"></span>   here=$PWD
<span class="anchor" id="line-3-24"></span>   cd "$subdir" &amp;&amp; whatever &amp;&amp; ...
<span class="anchor" id="line-4-14"></span>   cd "$here"
<span class="anchor" id="line-5-10"></span> done</pre><span class="anchor" id="line-580"></span><span class="anchor" id="line-581"></span></li></ul><p class="line874">With this: <span class="anchor" id="line-582"></span><span class="anchor" id="line-583"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-584"></span><span class="anchor" id="line-585"></span><span class="anchor" id="line-586"></span><span class="anchor" id="line-587"></span><pre><span class="anchor" id="line-1-53"></span> find ... -type d -print0 | while IFS= read -r -d '' subdir; do
<span class="anchor" id="line-2-32"></span>   (cd "$subdir" || exit; whatever; ...)
<span class="anchor" id="line-3-25"></span> done</pre><span class="anchor" id="line-588"></span><span class="anchor" id="line-589"></span></li></ul><p class="line862">Forcing a <a href="/SubShell">SubShell</a> here causes the <tt class="backtick">cd</tt> to occur only in the subshell; for the next iteration of the loop, we're back to our normal location, regardless of whether the <tt class="backtick">cd</tt> succeeded or failed.  We don't have to change back manually, and we aren't stuck in a neverending string of <tt class="backtick">...&nbsp;&amp;&amp;&nbsp;...</tt> logic preventing the use of other conditionals.  The subshell version is simpler and cleaner (albeit a tiny bit slower). <span class="anchor" id="line-590"></span><span class="anchor" id="line-591"></span><p class="line862">Another approach is to <tt class="backtick">cd</tt> unconditionally to where we're supposed to be, at the start of each loop iteration: <span class="anchor" id="line-592"></span><span class="anchor" id="line-593"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-594"></span><span class="anchor" id="line-595"></span><span class="anchor" id="line-596"></span><span class="anchor" id="line-597"></span><span class="anchor" id="line-598"></span><span class="anchor" id="line-599"></span><span class="anchor" id="line-600"></span><span class="anchor" id="line-601"></span><pre><span class="anchor" id="line-1-54"></span> here=$PWD
<span class="anchor" id="line-2-33"></span> find ... -type d -print0 | while IFS= read -r -d '' subdir; do
<span class="anchor" id="line-3-26"></span>    cd "$here" || continue
<span class="anchor" id="line-4-15"></span>    cd "$subdir" || continue
<span class="anchor" id="line-5-11"></span>    whatever
<span class="anchor" id="line-6-7"></span>    ...
<span class="anchor" id="line-7-3"></span> done</pre><span class="anchor" id="line-602"></span><span class="anchor" id="line-603"></span></li></ul><p class="line862">At least this way, we can <tt class="backtick">continue</tt> to the next loop iteration and don't have to string an indefinite series of <tt class="backtick">&amp;&amp;</tt> together to ensure that we reach the <tt class="backtick">cd</tt> at the end of the loop body. <span class="anchor" id="line-604"></span><span class="anchor" id="line-605"></span><p class="line867"><span class="anchor" id="pf20"></span> <span class="anchor" id="line-606"></span><span class="anchor" id="line-607"></span><p class="line867">
<h2 id="A.5B_bar_.3D.3D_.22.24foo.22_.5D">20. [ bar == "$foo" ]</h2>
<span class="anchor" id="line-608"></span><p class="line862">The <tt class="backtick">==</tt> operator is not valid for the POSIX <tt class="backtick">[</tt> command. Use <tt class="backtick">=</tt> or the <a href="/BashFAQ/031">[[ keyword</a> instead. <span class="anchor" id="line-609"></span><span class="anchor" id="line-610"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-611"></span><span class="anchor" id="line-612"></span><span class="anchor" id="line-613"></span><pre><span class="anchor" id="line-1-55"></span> [ bar = "$foo" ] &amp;&amp; echo yes
<span class="anchor" id="line-2-34"></span> [[ bar == $foo ]] &amp;&amp; echo yes</pre><span class="anchor" id="line-614"></span><span class="anchor" id="line-615"></span></li></ul><p class="line862">In Bash, <tt class="backtick">[&nbsp;"$x"&nbsp;==&nbsp;y&nbsp;]</tt> is accepted as an extension, which often leads Bash programmers to think it's the correct syntax.  It's not; it's a <a href="/Bashism">Bashism</a>.  If you're going to use Bashisms, you might as well just use <tt class="backtick">[[</tt> instead. <span class="anchor" id="line-616"></span><span class="anchor" id="line-617"></span><p class="line867"><span class="anchor" id="pf21"></span> <span class="anchor" id="line-618"></span><span class="anchor" id="line-619"></span><p class="line867">
<h2 id="for_i_in_.7B1..10.7D.3B_do_..2Fsomething_.26.3B_done">21. for i in {1..10}; do ./something &amp;; done</h2>
<span class="anchor" id="line-620"></span><p class="line862">You <em>cannot</em> put a <tt class="backtick">;</tt> immediately after an <tt class="backtick">&amp;</tt>. Just remove the extraneous <tt class="backtick">;</tt> entirely. <span class="anchor" id="line-621"></span><span class="anchor" id="line-622"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-623"></span><span class="anchor" id="line-624"></span><pre><span class="anchor" id="line-1-56"></span> for i in {1..10}; do ./something &amp; done</pre><span class="anchor" id="line-625"></span><span class="anchor" id="line-626"></span></li></ul><p class="line874">Or: <span class="anchor" id="line-627"></span><span class="anchor" id="line-628"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-629"></span><span class="anchor" id="line-630"></span><span class="anchor" id="line-631"></span><span class="anchor" id="line-632"></span><pre><span class="anchor" id="line-1-57"></span> for i in {1..10}; do
<span class="anchor" id="line-2-35"></span>   ./something &amp;
<span class="anchor" id="line-3-27"></span> done</pre><span class="anchor" id="line-633"></span><span class="anchor" id="line-634"></span></li></ul><p class="line867"><tt class="backtick">&amp;</tt> already functions as a command terminator, just like <tt class="backtick">;</tt> does. And you cannot mix the two. <span class="anchor" id="line-635"></span><span class="anchor" id="line-636"></span><p class="line862">In general, a <tt class="backtick">;</tt> can be replaced by a newline, but not all newlines can be replaced by <tt class="backtick">;</tt>. <span class="anchor" id="line-637"></span><span class="anchor" id="line-638"></span><p class="line867"><span class="anchor" id="pf22"></span> <span class="anchor" id="line-639"></span><span class="anchor" id="line-640"></span><p class="line867">
<h2 id="cmd1_.26.26_cmd2_.7C.7C_cmd3">22. cmd1 &amp;&amp; cmd2 || cmd3</h2>
<span class="anchor" id="line-641"></span><p class="line862">Some people try to use <tt class="backtick">&amp;&amp;</tt> and <tt class="backtick">||</tt> as a shortcut syntax for <tt class="backtick">if&nbsp;...&nbsp;then&nbsp;...&nbsp;else&nbsp;...&nbsp;fi</tt>, perhaps because they think they are being clever. For instance, <span class="anchor" id="line-642"></span><span class="anchor" id="line-643"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-644"></span><span class="anchor" id="line-645"></span><span class="anchor" id="line-646"></span><pre><span class="anchor" id="line-1-58"></span> # WRONG!
<span class="anchor" id="line-2-36"></span> [[ -s $errorlog ]] &amp;&amp; echo "Uh oh, there were some errors." || echo "Successful."</pre><span class="anchor" id="line-647"></span><span class="anchor" id="line-648"></span></li></ul><p class="line862">However, this construct is <em>not</em> completely equivalent to <tt class="backtick">if&nbsp;...&nbsp;fi</tt> in the general case.  The command that comes after the <tt class="backtick">&amp;&amp;</tt> also generates an exit status, and if that exit status isn't "true" (0), then the command that comes after the <tt class="backtick">||</tt> will <em>also</em> be invoked. For example: <span class="anchor" id="line-649"></span><span class="anchor" id="line-650"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-651"></span><span class="anchor" id="line-652"></span><span class="anchor" id="line-653"></span><span class="anchor" id="line-654"></span><pre><span class="anchor" id="line-1-59"></span> i=0
<span class="anchor" id="line-2-37"></span> true &amp;&amp; ((i++)) || ((i--))  # WRONG!
<span class="anchor" id="line-3-28"></span> echo "$i"                   # Prints 0</pre><span class="anchor" id="line-655"></span><span class="anchor" id="line-656"></span></li></ul><p class="line862">What happened here? It looks like <tt class="backtick">i</tt> should be 1, but it ends up 0. Why? Because both the <tt class="backtick">i++</tt> <em>and</em> the <tt class="backtick">i--</tt> were executed. The <tt class="backtick">((i++))</tt> command has an exit status, and that exit status is derived from a C-like evaluation of the expression inside the parentheses. That expression's value happens to be 0 (the initial value of <tt class="backtick">i</tt>), and in C, an expression with an integer value of 0 is considered <em>false</em>. So <tt class="backtick">((i++))</tt> (when <tt class="backtick">i</tt> is 0) has an exit status of 1 (false), and therefore the <tt class="backtick">((i--))</tt> command is executed as well. <span class="anchor" id="line-657"></span><span class="anchor" id="line-658"></span><p class="line862">Another clever person thinks that we can fix it by using the pre-increment operator, since the exit status from <tt class="backtick">++i</tt> (with <tt class="backtick">i</tt> initially 0) is true: <span class="anchor" id="line-659"></span><span class="anchor" id="line-660"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-661"></span><span class="anchor" id="line-662"></span><span class="anchor" id="line-663"></span><span class="anchor" id="line-664"></span><pre><span class="anchor" id="line-1-60"></span> i=0
<span class="anchor" id="line-2-38"></span> true &amp;&amp; (( ++i )) || (( --i ))  # STILL WRONG!
<span class="anchor" id="line-3-29"></span> echo "$i"                       # Prints 1 by dumb luck</pre><span class="anchor" id="line-665"></span><span class="anchor" id="line-666"></span></li></ul><p class="line862">But that's missing the point of the example. It just <em>happens</em> to work by <em>coincidence</em>, and you <em>cannot</em> rely on <tt class="backtick">x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;z</tt> if <tt class="backtick">y</tt> has <strong>any</strong> chance of failure! (This example still fails if we initialize <tt class="backtick">i</tt> to -1 instead of 0.) <span class="anchor" id="line-667"></span><span class="anchor" id="line-668"></span><p class="line862">If you need safety, or if you simply aren't sure how this works, or if <em>anything</em> in the preceding paragraphs wasn't completely clear, please just use the simple <tt class="backtick">if&nbsp;...&nbsp;fi</tt> syntax in your programs. <span class="anchor" id="line-669"></span><span class="anchor" id="line-670"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-671"></span><span class="anchor" id="line-672"></span><span class="anchor" id="line-673"></span><span class="anchor" id="line-674"></span><span class="anchor" id="line-675"></span><span class="anchor" id="line-676"></span><span class="anchor" id="line-677"></span><span class="anchor" id="line-678"></span><pre><span class="anchor" id="line-1-61"></span> i=0
<span class="anchor" id="line-2-39"></span> if true; then
<span class="anchor" id="line-3-30"></span>   ((i++))
<span class="anchor" id="line-4-16"></span> else
<span class="anchor" id="line-5-12"></span>   ((i--))
<span class="anchor" id="line-6-8"></span> fi
<span class="anchor" id="line-7-4"></span> echo "$i"    # Prints 1</pre><span class="anchor" id="line-679"></span><span class="anchor" id="line-680"></span></li></ul><p class="line874">This section also applies to Bourne shell, here is the code that illustrates it: <span class="anchor" id="line-681"></span><span class="anchor" id="line-682"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-683"></span><span class="anchor" id="line-684"></span><span class="anchor" id="line-685"></span><pre><span class="anchor" id="line-1-62"></span> # WRONG!
<span class="anchor" id="line-2-40"></span> true &amp;&amp; { echo true; false; } || { echo false; true; }</pre><span class="anchor" id="line-686"></span><span class="anchor" id="line-687"></span></li></ul><p class="line874">Output is two lines "true" and "false", instead the single line "true". <span class="anchor" id="line-688"></span><span class="anchor" id="line-689"></span><p class="line867"><span class="anchor" id="pf23"></span> <span class="anchor" id="line-690"></span><span class="anchor" id="line-691"></span><p class="line867">
<h2 id="echo_.22Hello_World.21.22">23. echo "Hello World!"</h2>
<span class="anchor" id="line-692"></span><p class="line874">The problem here is that, in an interactive Bash shell (in versions prior to 4.3), you'll see an error like: <span class="anchor" id="line-693"></span><span class="anchor" id="line-694"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-695"></span><span class="anchor" id="line-696"></span><pre><span class="anchor" id="line-1-63"></span> bash: !": event not found</pre><span class="anchor" id="line-697"></span><span class="anchor" id="line-698"></span></li></ul><p class="line862">This is because, in the default settings for an interactive shell, Bash performs csh-style history expansion using the exclamation point. This is <strong>not</strong> a problem in shell scripts; only in interactive shells. <span class="anchor" id="line-699"></span><span class="anchor" id="line-700"></span><p class="line874">Unfortunately, the obvious attempt to "fix" this won't work: <span class="anchor" id="line-701"></span><span class="anchor" id="line-702"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-703"></span><span class="anchor" id="line-704"></span><span class="anchor" id="line-705"></span><pre><span class="anchor" id="line-1-64"></span> $ echo "hi\!"
<span class="anchor" id="line-2-41"></span> hi\!</pre><span class="anchor" id="line-706"></span><span class="anchor" id="line-707"></span></li></ul><p class="line862">The easiest solution is unsetting the <tt class="backtick">histexpand</tt> option: this can be done with <tt class="backtick">set&nbsp;+H</tt> or <tt class="backtick">set&nbsp;+o&nbsp;histexpand</tt> <span class="anchor" id="line-708"></span><span class="anchor" id="line-709"></span><ul><li style="list-style-type:none"><p class="line862">Question: Why is playing with <tt class="backtick">histexpand</tt> more apropriate than single quotes? <span class="anchor" id="line-710"></span><ul><li style="list-style-type:none"><p class="line891"><em>I personally ran into this issue when I was manipulating song files, using commands like</em> <span class="anchor" id="line-711"></span><span class="anchor" id="line-712"></span><span class="anchor" id="line-713"></span><span class="anchor" id="line-714"></span><pre><span class="anchor" id="line-1-65"></span>mp3info -t "Don't Let It Show" ...
<span class="anchor" id="line-2-42"></span>mp3info -t "Ah! Leah!" ...</pre><span class="anchor" id="line-715"></span><p class="line891"><em>Using single quotes is extremely inconvenient because of all the songs with apostrophes in their titles. Using double quotes ran into the history expansion issue. (And imagine a file that has both in its name. The quoting would be atrocious.) Since I never actually </em>use<em> history expansion, my personal preference was to turn it off in <tt class="backtick">~/.bashrc</tt>.</em> -- <a href="/GreyCat">GreyCat</a> <span class="anchor" id="line-716"></span><span class="anchor" id="line-717"></span></li></ul></li></ul><p class="line874">These solutions will work: <span class="anchor" id="line-718"></span><span class="anchor" id="line-719"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-720"></span><span class="anchor" id="line-721"></span><pre><span class="anchor" id="line-1-66"></span> echo 'Hello World!'</pre><span class="anchor" id="line-722"></span><span class="anchor" id="line-723"></span></li></ul><p class="line874">or <span class="anchor" id="line-724"></span><span class="anchor" id="line-725"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-726"></span><span class="anchor" id="line-727"></span><pre><span class="anchor" id="line-1-67"></span> echo "Hello World"!</pre><span class="anchor" id="line-728"></span><span class="anchor" id="line-729"></span></li></ul><p class="line874">or <span class="anchor" id="line-730"></span><span class="anchor" id="line-731"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-732"></span><span class="anchor" id="line-733"></span><span class="anchor" id="line-734"></span><pre><span class="anchor" id="line-1-68"></span> set +H
<span class="anchor" id="line-2-43"></span> echo "Hello World!"</pre><span class="anchor" id="line-735"></span><span class="anchor" id="line-736"></span></li></ul><p class="line874">or <span class="anchor" id="line-737"></span><span class="anchor" id="line-738"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-739"></span><span class="anchor" id="line-740"></span><pre><span class="anchor" id="line-1-69"></span> histchars=</pre><span class="anchor" id="line-741"></span><span class="anchor" id="line-742"></span></li></ul><p class="line862">Many people simply choose to put <tt class="backtick">set&nbsp;+H</tt> or <tt class="backtick">set&nbsp;+o&nbsp;histexpand</tt> in their <tt class="backtick">~/.bashrc</tt> to deactivate history expansion permanently. This is a personal preference, though, and you should choose whatever works best for you. <span class="anchor" id="line-743"></span><span class="anchor" id="line-744"></span><p class="line874">Another solution is: <span class="anchor" id="line-745"></span><span class="anchor" id="line-746"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-747"></span><span class="anchor" id="line-748"></span><span class="anchor" id="line-749"></span><pre><span class="anchor" id="line-1-70"></span> exmark='!'
<span class="anchor" id="line-2-44"></span> echo "Hello, world$exmark"</pre><span class="anchor" id="line-750"></span><span class="anchor" id="line-751"></span></li></ul><p class="line862">In Bash 4.3 and newer, a double quote following <tt class="backtick">!</tt> no longer triggers history expansion, but history expansion is still performed within double quotes, so while <tt class="backtick">echo&nbsp;"Hello&nbsp;World!"</tt> is OK, these will still be a problem: <span class="anchor" id="line-752"></span><span class="anchor" id="line-753"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-754"></span><span class="anchor" id="line-755"></span><span class="anchor" id="line-756"></span><pre><span class="anchor" id="line-1-71"></span> echo "Hello, World!(and the rest of the Universe)"
<span class="anchor" id="line-2-45"></span> echo "foo!'bar'"</pre><span class="anchor" id="line-757"></span><span class="anchor" id="line-758"></span></li></ul><p class="line867"><span class="anchor" id="pf24"></span> <span class="anchor" id="line-759"></span><span class="anchor" id="line-760"></span><p class="line867">
<h2 id="for_arg_in_.24.2A">24. for arg in $*</h2>
<span class="anchor" id="line-761"></span><p class="line862">Bash (like all Bourne shells) has a special syntax for referring to the list of positional parameters one at a time, and <tt class="backtick">$*</tt> isn't it. Neither is <tt class="backtick">$@</tt>. Both of those expand to the list of words in your script's parameters, not to each parameter as a separate word. <span class="anchor" id="line-762"></span><span class="anchor" id="line-763"></span><p class="line874">The correct syntax is: <span class="anchor" id="line-764"></span><span class="anchor" id="line-765"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-766"></span><span class="anchor" id="line-767"></span><span class="anchor" id="line-768"></span><span class="anchor" id="line-769"></span><span class="anchor" id="line-770"></span><pre><span class="anchor" id="line-1-72"></span> for arg in "$@"
<span class="anchor" id="line-2-46"></span>
<span class="anchor" id="line-3-31"></span> # Or simply:
<span class="anchor" id="line-4-17"></span> for arg</pre><span class="anchor" id="line-771"></span><span class="anchor" id="line-772"></span></li></ul><p class="line862">Since looping over the positional parameters is such a common thing to do in scripts, <tt class="backtick">for&nbsp;arg</tt> defaults to <tt class="backtick">for&nbsp;arg&nbsp;in&nbsp;"$@"</tt>. The double-quoted <tt class="backtick">"$@"</tt> is special magic that causes each parameter to be used as a single word (or a single loop iteration). It's what you should be using at least 99% of the time. <span class="anchor" id="line-773"></span><span class="anchor" id="line-774"></span><p class="line874">Here's an example: <span class="anchor" id="line-775"></span><span class="anchor" id="line-776"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-777"></span><span class="anchor" id="line-778"></span><span class="anchor" id="line-779"></span><span class="anchor" id="line-780"></span><span class="anchor" id="line-781"></span><span class="anchor" id="line-782"></span><span class="anchor" id="line-783"></span><span class="anchor" id="line-784"></span><span class="anchor" id="line-785"></span><span class="anchor" id="line-786"></span><span class="anchor" id="line-787"></span><pre><span class="anchor" id="line-1-73"></span> # Incorrect version
<span class="anchor" id="line-2-47"></span> for x in $*; do
<span class="anchor" id="line-3-32"></span>   echo "parameter: '$x'"
<span class="anchor" id="line-4-18"></span> done
<span class="anchor" id="line-5-13"></span>
<span class="anchor" id="line-6-9"></span> $ ./myscript 'arg 1' arg2 arg3
<span class="anchor" id="line-7-5"></span> parameter: 'arg'
<span class="anchor" id="line-8-3"></span> parameter: '1'
<span class="anchor" id="line-9-3"></span> parameter: 'arg2'
<span class="anchor" id="line-10-2"></span> parameter: 'arg3'</pre><span class="anchor" id="line-788"></span><span class="anchor" id="line-789"></span></li></ul><p class="line874">It should have been written: <span class="anchor" id="line-790"></span><span class="anchor" id="line-791"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-792"></span><span class="anchor" id="line-793"></span><span class="anchor" id="line-794"></span><span class="anchor" id="line-795"></span><span class="anchor" id="line-796"></span><span class="anchor" id="line-797"></span><span class="anchor" id="line-798"></span><span class="anchor" id="line-799"></span><span class="anchor" id="line-800"></span><span class="anchor" id="line-801"></span><span class="anchor" id="line-802"></span><span class="anchor" id="line-803"></span><span class="anchor" id="line-804"></span><span class="anchor" id="line-805"></span><pre><span class="anchor" id="line-1-74"></span> # Correct version
<span class="anchor" id="line-2-48"></span> for x in "$@"; do
<span class="anchor" id="line-3-33"></span>   echo "parameter: '$x'"
<span class="anchor" id="line-4-19"></span> done
<span class="anchor" id="line-5-14"></span># or better:
<span class="anchor" id="line-6-10"></span> for x do
<span class="anchor" id="line-7-6"></span>   echo "parameter: '$x'"
<span class="anchor" id="line-8-4"></span> done
<span class="anchor" id="line-9-4"></span>
<span class="anchor" id="line-10-3"></span> $ ./myscript 'arg 1' arg2 arg3
<span class="anchor" id="line-11-2"></span> parameter: 'arg 1'
<span class="anchor" id="line-12-2"></span> parameter: 'arg2'
<span class="anchor" id="line-13-1"></span> parameter: 'arg3'</pre><span class="anchor" id="line-806"></span><span class="anchor" id="line-807"></span></li></ul><p class="line867"><span class="anchor" id="pf25"></span> <span class="anchor" id="line-808"></span><span class="anchor" id="line-809"></span><p class="line867">
<h2 id="function_foo.28.29">25. function foo()</h2>
<span class="anchor" id="line-810"></span><p class="line862">This works in some shells, but not in others. You should <em>never</em> combine the keyword <tt class="backtick">function</tt> with the parentheses <tt class="backtick">()</tt> when defining a function. <span class="anchor" id="line-811"></span><span class="anchor" id="line-812"></span><p class="line862">Bash (at least some versions) will allow you to mix the two. Most of the shells won't accept that (zsh 4.x and perhaps above will - for example). Some shells will accept <tt class="backtick">function&nbsp;foo</tt>, but for maximum portability, you should always use: <span class="anchor" id="line-813"></span><span class="anchor" id="line-814"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-815"></span><span class="anchor" id="line-816"></span><span class="anchor" id="line-817"></span><span class="anchor" id="line-818"></span><pre><span class="anchor" id="line-1-75"></span> foo() {
<span class="anchor" id="line-2-49"></span>  ...
<span class="anchor" id="line-3-34"></span> }</pre><span class="anchor" id="line-819"></span><span class="anchor" id="line-820"></span></li></ul><p class="line867"><span class="anchor" id="pf26"></span> <span class="anchor" id="line-821"></span><span class="anchor" id="line-822"></span><p class="line867">
<h2 id="echo_.22.2BAH4.22">26. echo "~"</h2>
<span class="anchor" id="line-823"></span><p class="line874">Tilde expansion only applies when '~' is unquoted. In this example echo writes '~' to stdout, rather than the path of the user's home directory. <span class="anchor" id="line-824"></span><span class="anchor" id="line-825"></span><p class="line874">Quoting path parameters that are expressed relative to a user's home directory should be done using $HOME rather than '~'. For instance consider the situation where $HOME is "/home/my photos". <span class="anchor" id="line-826"></span><span class="anchor" id="line-827"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-828"></span><span class="anchor" id="line-829"></span><span class="anchor" id="line-830"></span><span class="anchor" id="line-831"></span><span class="anchor" id="line-832"></span><pre><span class="anchor" id="line-1-76"></span> "~/dir with spaces" # expands to "~/dir with spaces"
<span class="anchor" id="line-2-50"></span> ~"/dir with spaces" # expands to "~/dir with spaces"
<span class="anchor" id="line-3-35"></span> ~/"dir with spaces" # expands to "/home/my photos/dir with spaces"
<span class="anchor" id="line-4-20"></span> "$HOME/dir with spaces" # expands to "/home/my photos/dir with spaces"</pre><span class="anchor" id="line-833"></span><span class="anchor" id="line-834"></span></li></ul><p class="line867"><span class="anchor" id="pf27"></span> <span class="anchor" id="line-835"></span><span class="anchor" id="line-836"></span><p class="line867">
<h2 id="local_var.3D.24.28cmd.29">27. local var=$(cmd)</h2>
<span class="anchor" id="line-837"></span><p class="line862">When declaring a local variable in a function, the <tt class="backtick">local</tt> acts as a command in its own right. This can sometimes interact oddly with the rest of the line -- for example, if you wanted to capture the exit status (<tt class="backtick">$?</tt>) of the <a href="/CommandSubstitution">CommandSubstitution</a>, you can't do it. <tt class="backtick">local</tt>'s exit status masks it. <span class="anchor" id="line-838"></span><span class="anchor" id="line-839"></span><p class="line862">Another problem with this syntax is that in some shells (like bash), <tt class="backtick">local&nbsp;var=$(cmd)</tt> is treated as an <em>assignment</em>, meaning the right hand side is given special treatment, just like <tt class="backtick">var=$(cmd)</tt>; while in other shells (like dash), <tt class="backtick">local&nbsp;var=$(cmd)</tt> is <strong>not</strong> treated as an assignment, and the right hand side will undergo <a href="/WordSplitting">word splitting</a> (because it isn't quoted). <span class="anchor" id="line-840"></span><span class="anchor" id="line-841"></span><p class="line874">Quoting the right hand side will work around the word splitting issue, but not the exit status masking issue.  For both reasons, it's best to use separate commands for this: <span class="anchor" id="line-842"></span><span class="anchor" id="line-843"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-844"></span><span class="anchor" id="line-845"></span><span class="anchor" id="line-846"></span><span class="anchor" id="line-847"></span><pre><span class="anchor" id="line-1-77"></span> local var
<span class="anchor" id="line-2-51"></span> var=$(cmd)
<span class="anchor" id="line-3-36"></span> rc=$?</pre><span class="anchor" id="line-848"></span><span class="anchor" id="line-849"></span></li></ul><p class="line862">Both issues are also true of <tt class="backtick">export</tt>. <span class="anchor" id="line-850"></span><span class="anchor" id="line-851"></span><p class="line874">The next pitfall describes another issue with this syntax: <span class="anchor" id="line-852"></span><span class="anchor" id="line-853"></span><p class="line867"><span class="anchor" id="pf28"></span> <span class="anchor" id="line-854"></span><span class="anchor" id="line-855"></span><p class="line867">
<h2 id="export_foo.3D.2BAH4-.2Fbar">28. export foo=~/bar</h2>
<span class="anchor" id="line-856"></span><p class="line867"><a class="nonexistent" href="/TildeExpansion">Tilde expansion</a> (with or without a username) is only guaranteed to occur when the tilde appears at the beginning of a <a href="/Arguments">word</a>, either by itself or followed by a slash.  It is also guaranteed to occur when the tilde appears immediately after the <tt class="backtick">=</tt> in an assignment. <span class="anchor" id="line-857"></span><span class="anchor" id="line-858"></span><p class="line862">However, the <tt class="backtick">export</tt> and <tt class="backtick">local</tt> commands do <strong>not</strong> necessarily constitute an assignment.  In some shells (like Bash), <tt class="backtick">export&nbsp;foo=~/bar</tt> will undergo tilde expansion; in others (like dash), it will not. <span class="anchor" id="line-859"></span><span class="anchor" id="line-860"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-861"></span><span class="anchor" id="line-862"></span><span class="anchor" id="line-863"></span><pre><span class="anchor" id="line-1-78"></span> foo=~/bar; export foo    # Right!
<span class="anchor" id="line-2-52"></span> export foo="$HOME/bar"   # Right!</pre><span class="anchor" id="line-864"></span><span class="anchor" id="line-865"></span></li></ul><p class="line867"><span class="anchor" id="pf29"></span> <span class="anchor" id="line-866"></span><span class="anchor" id="line-867"></span><p class="line867">
<h2 id="sed_.27s.2F.24foo.2Fgood_bye.2F.27">29. sed 's/$foo/good bye/'</h2>
<span class="anchor" id="line-868"></span><p class="line862">In <a href="/Quotes">single quotes</a>, bash parameter expansions like <tt class="backtick">$foo</tt> do not get expanded.  That is the purpose of single quotes, to protect characters like <tt class="backtick">$</tt> from the shell. <span class="anchor" id="line-869"></span><span class="anchor" id="line-870"></span><p class="line874">Change the quotes to double quotes: <span class="anchor" id="line-871"></span><span class="anchor" id="line-872"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-873"></span><span class="anchor" id="line-874"></span><pre><span class="anchor" id="line-1-79"></span> foo="hello"; sed "s/$foo/good bye/"</pre><span class="anchor" id="line-875"></span><span class="anchor" id="line-876"></span></li></ul><p class="line862">But keep in mind, if you use double quotes you might need to use more escapes.  See the <a href="/Quotes">Quotes</a> page. <span class="anchor" id="line-877"></span><span class="anchor" id="line-878"></span><p class="line867"><span class="anchor" id="pf30"></span> <span class="anchor" id="line-879"></span><span class="anchor" id="line-880"></span><p class="line867">
<h2 id="tr_.5BA-Z.5D_.5Ba-z.5D">30. tr [A-Z] [a-z]</h2>
<span class="anchor" id="line-881"></span><p class="line862">There are (at least) three things wrong here.  The first problem is that <tt class="backtick">[A-Z]</tt> and <tt class="backtick">[a-z]</tt> are seen as <a href="/glob">glob</a>s by the shell.  If you don't have any single-lettered filenames in your current directory, it'll seem like the command is correct; but if you do, things will go wrong.  Probably at 0300 hours on a weekend. <span class="anchor" id="line-882"></span><span class="anchor" id="line-883"></span><p class="line862">The second problem is that this is not really the correct notation for <tt class="backtick">tr</tt>.  What this actually does is translate '[' into '['; anything in the range A-Z into a-z; and ']' into ']'.  So you don't even need those brackets, and the first problem goes away. <span class="anchor" id="line-884"></span><span class="anchor" id="line-885"></span><p class="line862">The third problem is that depending on the <a href="/locale">locale</a>, A-Z or a-z may not give you the 26 ASCII characters you were expecting.  In fact, in some locales z is in the middle of the alphabet!  The solution to this depends on what you want to happen: <span class="anchor" id="line-886"></span><span class="anchor" id="line-887"></span><ul><li style="list-style-type:none"><span class="anchor" id="line-888"></span><span class="anchor" id="line-889"></span><span class="anchor" id="line-890"></span><span class="anchor" id="line-891"></span><span class="anchor" id="line-892"></span><span class="anchor" id="line-893"></span><pre><span class="anchor" id="line-1-80"></span> # Use this if you want to change the case of the 26 latin letters
<span class="anchor" id="line-2-53"></span> LC_COLLATE=C tr A-Z a-z
<span class="anchor" id="line-3-37"></span>
<span class="anchor" id="line-4-21"></span> # Use this if you want the case conversion to depend upon the locale, which might be more like what a user is expecting
<span class="anchor" id="line-5-15"></span> tr '[:upper:]' '[:lower:]'</pre><span class="anchor" id="line-894"></span><span class="anchor" id="line-895"></span></li></ul><p class="line862">The quotes are required on the second command, to avoid <a href="/glob">globbing</a>. <span class="anchor" id="line-896"></span><span class="anchor" id="line-897"></span><p class="line867"><span class="anchor" id="pf31"></span> <span class="anchor" id="line-898"></span><span class="anchor" id="line-899"></span><p class="line867">
<h2 id="ps_ax_.7C_grep_gedit">31. ps ax | grep gedit</h2>
<span class="anchor" id="line-900"></span><p class="line862">The fundamental problem here is that the name of a running process is inherently unreliable.  There could be more than one legitimate gedit process.  There could be something else disguising itself as gedit (changing the reported name of an executed command is trivial).  For <em>real</em> answers to this, see <a href="/ProcessManagement">ProcessManagement</a>. <span class="anchor" id="line-901"></span><span class="anchor" id="line-902"></span><p class="line874">The following is the quick and dirty stuff. <span class="anchor" id="line-903"></span><span class="anchor" id="line-904"></span><p class="line874">Searching for the PID of (for example) gedit, many people start with <span class="anchor" id="line-905"></span><span class="anchor" id="line-906"></span><p class="line867"><span class="anchor" id="line-907"></span><span class="anchor" id="line-908"></span><span class="anchor" id="line-909"></span><span class="anchor" id="line-910"></span><pre><span class="anchor" id="line-1-81"></span>$ ps ax | grep gedit
<span class="anchor" id="line-2-54"></span>10530 ?        S      6:23 gedit
<span class="anchor" id="line-3-38"></span>32118 pts/0    R+     0:00 grep gedit</pre><span class="anchor" id="line-911"></span><p class="line862">which, depending on a <a href="/RaceCondition">RaceCondition</a>, often yields grep itself as a result.  To filter grep out: <span class="anchor" id="line-912"></span><span class="anchor" id="line-913"></span><p class="line867"><span class="anchor" id="line-914"></span><span class="anchor" id="line-915"></span><pre><span class="anchor" id="line-1-82"></span>ps ax | grep -v grep | grep gedit   # will work, but ugly</pre><span class="anchor" id="line-916"></span><p class="line874">An alternative to this is to use: <span class="anchor" id="line-917"></span><span class="anchor" id="line-918"></span><p class="line867"><span class="anchor" id="line-919"></span><span class="anchor" id="line-920"></span><pre><span class="anchor" id="line-1-83"></span>ps ax | grep '[g]edit'              # quote to avoid shell GLOB</pre><span class="anchor" id="line-921"></span><p class="line874">This will ignore the grep itself in the process table as that is [g]edit and grep is looking for gedit once evaluated. <span class="anchor" id="line-922"></span><span class="anchor" id="line-923"></span><p class="line874">On GNU/Linux, the parameter -C can be used instead to filter by commandname: <span class="anchor" id="line-924"></span><span class="anchor" id="line-925"></span><p class="line867"><span class="anchor" id="line-926"></span><span class="anchor" id="line-927"></span><span class="anchor" id="line-928"></span><span class="anchor" id="line-929"></span><pre><span class="anchor" id="line-1-84"></span>$ ps -C gedit
<span class="anchor" id="line-2-55"></span>  PID TTY          TIME CMD
<span class="anchor" id="line-3-39"></span>10530 ?        00:06:23 gedit</pre><span class="anchor" id="line-930"></span><p class="line874">But why bother when you could just use pgrep instead? <span class="anchor" id="line-931"></span><span class="anchor" id="line-932"></span><p class="line867"><span class="anchor" id="line-933"></span><span class="anchor" id="line-934"></span><span class="anchor" id="line-935"></span><pre><span class="anchor" id="line-1-85"></span>$ pgrep gedit
<span class="anchor" id="line-2-56"></span>10530</pre><span class="anchor" id="line-936"></span><p class="line874">Now in a second step the PID is often extracted by awk or cut: <span class="anchor" id="line-937"></span><span class="anchor" id="line-938"></span><p class="line867"><span class="anchor" id="line-939"></span><span class="anchor" id="line-940"></span><pre><span class="anchor" id="line-1-86"></span>$ ps -C gedit | awk '{print $1}' | tail -n1</pre><span class="anchor" id="line-941"></span><p class="line874">but even that can be handled by some of the trillions of parameters for ps: <span class="anchor" id="line-942"></span><span class="anchor" id="line-943"></span><p class="line867"><span class="anchor" id="line-944"></span><span class="anchor" id="line-945"></span><span class="anchor" id="line-946"></span><pre><span class="anchor" id="line-1-87"></span>$ ps -C gedit -opid=
<span class="anchor" id="line-2-57"></span>10530</pre><span class="anchor" id="line-947"></span><p class="line874">If you're stuck in 1992 and aren't using pgrep, you could use the ancient, obsolete, deprecated pidof (GNU/Linux only) instead: <span class="anchor" id="line-948"></span><span class="anchor" id="line-949"></span><p class="line867"><span class="anchor" id="line-950"></span><span class="anchor" id="line-951"></span><span class="anchor" id="line-952"></span><pre><span class="anchor" id="line-1-88"></span>$ pidof gedit
<span class="anchor" id="line-2-58"></span>10530</pre><span class="anchor" id="line-953"></span><p class="line862">and if you need the PID to kill the process, <em>pkill</em> might be interesting for you. Note however that, for example, <tt class="backtick">pgrep/pkill&nbsp;ssh</tt> would also find processes named sshd, and you wouldn't want to kill those. <span class="anchor" id="line-954"></span><span class="anchor" id="line-955"></span><p class="line862">Unfortunately some programs aren't started with their name, for example firefox is often started as firefox-bin, which you would need to find out with - well - <strong>ps ax | grep firefox</strong>. <img alt=":)" height="16" src="/moin_static198/modernized/img/smile.png" title=":)" width="16" /> Or, you can stick with pgrep by adding some parameters: <span class="anchor" id="line-956"></span><span class="anchor" id="line-957"></span><p class="line867"><span class="anchor" id="line-958"></span><span class="anchor" id="line-959"></span><span class="anchor" id="line-960"></span><span class="anchor" id="line-961"></span><pre><span class="anchor" id="line-1-89"></span>$ pgrep -fl firefox
<span class="anchor" id="line-2-59"></span>3128 /usr/lib/firefox/firefox
<span class="anchor" id="line-3-40"></span>7120 /usr/lib/firefox/plugin-container /usr/lib/flashplugin-installer/libflashplayer.so -greomni /usr/lib/firefox/omni.ja 3128 true plugin</pre><span class="anchor" id="line-962"></span><p class="line862">Please read <a href="/ProcessManagement">ProcessManagement</a>.  Seriously. <span class="anchor" id="line-963"></span><span class="anchor" id="line-964"></span><p class="line867"><span class="anchor" id="pf32"></span> <span class="anchor" id="line-965"></span><span class="anchor" id="line-966"></span><p class="line867">
<h2 id="printf_.22.24foo.22">32. printf "$foo"</h2>
<span class="anchor" id="line-967"></span><p class="line862">This isn't wrong because of <a href="/Quotes">quotes</a>, but because of a <em>format string exploit</em>.  If <tt class="backtick">$foo</tt> is not strictly under your control, then any <tt class="backtick">\</tt> or <tt class="backtick">%</tt> characters in the variable may cause undesired behavior. <span class="anchor" id="line-968"></span><span class="anchor" id="line-969"></span><p class="line874">Always supply your own format string: <span class="anchor" id="line-970"></span><span class="anchor" id="line-971"></span><p class="line867"><span class="anchor" id="line-972"></span><span class="anchor" id="line-973"></span><span class="anchor" id="line-974"></span><pre><span class="anchor" id="line-1-90"></span>printf %s "$foo"
<span class="anchor" id="line-2-60"></span>printf '%s\n' "$foo"</pre><span class="anchor" id="line-975"></span><p class="line867"><span class="anchor" id="pf33"></span> <span class="anchor" id="line-976"></span><span class="anchor" id="line-977"></span><p class="line867">
<h2 id="for_i_in_.7B1...24n.7D">33. for i in {1..$n}</h2>
<span class="anchor" id="line-978"></span><p class="line862">The <a href="/BashParser">BashParser</a> performs <a href="/BraceExpansion">BraceExpansion</a> <em>before</em> any other expansions or substitutions.  So the brace expansion code sees the literal <tt class="backtick">$n</tt>, which is not numeric, and therefore it doesn't expand the curly braces into a list of numbers.  This makes it nearly impossible to use brace expansion to create lists whose size is only known at run-time. <span class="anchor" id="line-979"></span><span class="anchor" id="line-980"></span><p class="line874">Do this instead: <span class="anchor" id="line-981"></span><span class="anchor" id="line-982"></span><p class="line867"><span class="anchor" id="line-983"></span><span class="anchor" id="line-984"></span><span class="anchor" id="line-985"></span><span class="anchor" id="line-986"></span><pre><span class="anchor" id="line-1-91"></span>for ((i=1; i&lt;=n; i++)); do
<span class="anchor" id="line-2-61"></span>...
<span class="anchor" id="line-3-41"></span>done</pre><span class="anchor" id="line-987"></span><p class="line862">In the case of simple iteration over integers, an arithmetic <tt class="backtick">for</tt> loop should almost always be preferred over brace expansion to begin with, because brace expansion pre-expands every argument which can be slower and unnecessarily consumes memory. <span class="anchor" id="line-988"></span><span class="anchor" id="line-989"></span><p class="line867"><span class="anchor" id="pf34"></span> <span class="anchor" id="line-990"></span><span class="anchor" id="line-991"></span><p class="line867">
<h2 id="if_.5B.5B_.24foo_.3D_.24bar_.5D.5D_.28depending_on_intent.29">34. if [[ $foo = $bar ]] (depending on intent)</h2>
<span class="anchor" id="line-992"></span><p class="line862">When the right-hand side of an <tt class="backtick">=</tt> operator inside <a href="/BashFAQ/031">[[</a> is not quoted, bash does <a href="/glob">pattern matching</a> against it, instead of treating it as a string.  So, in the code above, if <tt class="backtick">bar</tt> contains <tt class="backtick">*</tt>, the result will <em>always</em> be true.  If you want to check for equality of strings, the right-hand side should be quoted: <span class="anchor" id="line-993"></span><span class="anchor" id="line-994"></span><p class="line867"><span class="anchor" id="line-995"></span><span class="anchor" id="line-996"></span><pre><span class="anchor" id="line-1-92"></span>if [[ $foo = "$bar" ]]</pre><span class="anchor" id="line-997"></span><p class="line874">If you want to do pattern matching, it might be wise to choose variable names that indicate the right-hand side contains a pattern.  Or use comments. <span class="anchor" id="line-998"></span><span class="anchor" id="line-999"></span><p class="line862">It's also worth pointing out that if you quote the right-hand side of <tt class="backtick">=~</tt> it <em>also</em> forces a simple string comparison, rather than a regular expression matching.  This leads us to: <span class="anchor" id="line-1000"></span><span class="anchor" id="line-1001"></span><p class="line867"><span class="anchor" id="pf35"></span> <span class="anchor" id="line-1002"></span><span class="anchor" id="line-1003"></span><p class="line867">
<h2 id="if_.5B.5B_.24foo_.3D.2BAH4_.27some_RE.27_.5D.5D">35. if [[ $foo =~ 'some RE' ]]</h2>
<span class="anchor" id="line-1004"></span><p class="line862">The quotes around the right-hand side of the <tt class="backtick">=~</tt> operator cause it to become a string, rather than a <a href="/RegularExpression">RegularExpression</a>.  If you want to use a long or complicated regular expression and avoid lots of backslash escaping, put it in a variable: <span class="anchor" id="line-1005"></span><span class="anchor" id="line-1006"></span><p class="line867"><span class="anchor" id="line-1007"></span><span class="anchor" id="line-1008"></span><span class="anchor" id="line-1009"></span><pre><span class="anchor" id="line-1-93"></span>re='some RE'
<span class="anchor" id="line-2-62"></span>if [[ $foo =~ $re ]]</pre><span class="anchor" id="line-1010"></span><p class="line862">This also works around the difference in how <tt class="backtick">=~</tt> works across different versions of bash.  Using a variable avoids some nasty and subtle problems. <span class="anchor" id="line-1011"></span><span class="anchor" id="line-1012"></span><p class="line862">The same problem occurs with <a href="/glob">pattern matching</a> inside <tt class="backtick">[[</tt>: <span class="anchor" id="line-1013"></span><span class="anchor" id="line-1014"></span><p class="line867"><span class="anchor" id="line-1015"></span><span class="anchor" id="line-1016"></span><span class="anchor" id="line-1017"></span><pre><span class="anchor" id="line-1-94"></span>[[ $foo = "*.glob" ]]      # Wrong! *.glob is treated as a literal string.
<span class="anchor" id="line-2-63"></span>[[ $foo = *.glob ]]        # Correct. *.glob is treated as a glob-style pattern.</pre><span class="anchor" id="line-1018"></span><p class="line867"><span class="anchor" id="pf36"></span> <span class="anchor" id="line-1019"></span><span class="anchor" id="line-1020"></span><p class="line867">
<h2 id="A.5B_-n_.24foo_.5D_or_.5B_-z_.24foo_.5D">36. [ -n $foo ] or [ -z $foo ]</h2>
<span class="anchor" id="line-1021"></span><p class="line862">When using the <tt class="backtick">[</tt> command, you <strong>must</strong> <a href="/Quotes">quote</a> each substitution that you give it.  Otherwise, <tt class="backtick">$foo</tt> could expand to 0 words, or 42 words, or any number of words that isn't 1, which breaks the syntax. <span class="anchor" id="line-1022"></span><span class="anchor" id="line-1023"></span><p class="line867"><span class="anchor" id="line-1024"></span><span class="anchor" id="line-1025"></span><span class="anchor" id="line-1026"></span><span class="anchor" id="line-1027"></span><span class="anchor" id="line-1028"></span><span class="anchor" id="line-1029"></span><span class="anchor" id="line-1030"></span><span class="anchor" id="line-1031"></span><pre><span class="anchor" id="line-1-95"></span>[ -n "$foo" ]
<span class="anchor" id="line-2-64"></span>[ -z "$foo" ]
<span class="anchor" id="line-3-42"></span>[ -n "$(some command with a "$file" in it)" ]
<span class="anchor" id="line-4-22"></span>
<span class="anchor" id="line-5-16"></span># [[ doesn't perform word-splitting or glob expansion, so you could also use:
<span class="anchor" id="line-6-11"></span>[[ -n $foo ]]
<span class="anchor" id="line-7-7"></span>[[ -z $foo ]]</pre><span class="anchor" id="line-1032"></span><p class="line867"><span class="anchor" id="pf37"></span> <span class="anchor" id="line-1033"></span><span class="anchor" id="line-1034"></span><p class="line867">
<h2 id="A.5B.5B_-e_.22.24broken_symlink.22_.5D.5D_returns_1_even_though_.24broken_symlink_exists">37. [[ -e "$broken_symlink" ]] returns 1 even though $broken_symlink exists</h2>
<span class="anchor" id="line-1035"></span><p class="line874">Test follows symlinks, therefore if a symlink is broken, i.e. it points to a file that doesn't exists or is in a directory you don't have access to, test -e returns 1 for it even though it exists. <span class="anchor" id="line-1036"></span><span class="anchor" id="line-1037"></span><p class="line874">In order to work around it (and prepare against it) you should use: <span class="anchor" id="line-1038"></span><span class="anchor" id="line-1039"></span><p class="line867"><span class="anchor" id="line-1040"></span><span class="anchor" id="line-1041"></span><span class="anchor" id="line-1042"></span><span class="anchor" id="line-1043"></span><span class="anchor" id="line-1044"></span><span class="anchor" id="line-1045"></span><pre><span class="anchor" id="line-1-96"></span># bash/ksh/zsh
<span class="anchor" id="line-2-65"></span>[[ -e "$broken_symlink" || -L "$broken_symlink" ]]
<span class="anchor" id="line-3-43"></span>
<span class="anchor" id="line-4-23"></span># POSIX sh+test
<span class="anchor" id="line-5-17"></span>[ -e "$broken_symlink" ] || [ -L "$broken_symlink" ]</pre><span class="anchor" id="line-1046"></span><p class="line867"><span class="anchor" id="pf38"></span> <span class="anchor" id="line-1047"></span><span class="anchor" id="line-1048"></span><p class="line867">
<h2 id="ed_file_.3C.3C.3C.22g.2Fd.2BAFw.7B0.2C3.2BAFw.7D.2Fs.2F.2Fe.2Fg.22_fails">38. ed file &lt;&lt;&lt;"g/d\{0,3\}/s//e/g" fails</h2>
<span class="anchor" id="line-1049"></span><p class="line874">The problem caused because ed doesn't accept 0 for \{0,3\}. <span class="anchor" id="line-1050"></span><span class="anchor" id="line-1051"></span><p class="line874">You can check that the following do work: <span class="anchor" id="line-1052"></span><span class="anchor" id="line-1053"></span><p class="line867"><span class="anchor" id="line-1054"></span><span class="anchor" id="line-1055"></span><pre><span class="anchor" id="line-1-97"></span>ed file &lt;&lt;&lt;"g/d\{1,3\}/s//e/g"</pre><span class="anchor" id="line-1056"></span><p class="line862">Note that this happens even though POSIX states that BRE (which is the Regular Expression flavor used by ed) <a class="http" href="http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_06">should accept 0 as the minimum number of occurrences (see section 5)</a>. <span class="anchor" id="line-1057"></span><span class="anchor" id="line-1058"></span><p class="line867"><span class="anchor" id="pf39"></span> <span class="anchor" id="line-1059"></span><span class="anchor" id="line-1060"></span><p class="line867">
<h2 id="expr_sub-string_fails_for_.22match.22">39. expr sub-string fails for "match"</h2>
<span class="anchor" id="line-1061"></span><p class="line874">This works reasonably well <span class="anchor" id="line-1062"></span><span class="anchor" id="line-1063"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-1064"></span>most of the time <span class="anchor" id="line-1065"></span><span class="anchor" id="line-1066"></span><p class="line867"><span class="anchor" id="line-1067"></span><span class="anchor" id="line-1068"></span><span class="anchor" id="line-1069"></span><span class="anchor" id="line-1070"></span><pre><span class="anchor" id="line-1-98"></span>word=abcde
<span class="anchor" id="line-2-66"></span>expr "$word" : ".\(.*\)"
<span class="anchor" id="line-3-44"></span>bcde</pre><span class="anchor" id="line-1071"></span><p class="line874">But WILL fail for the word "match" <span class="anchor" id="line-1072"></span><span class="anchor" id="line-1073"></span><p class="line867"><span class="anchor" id="line-1074"></span><span class="anchor" id="line-1075"></span><span class="anchor" id="line-1076"></span><pre><span class="anchor" id="line-1-99"></span>word=match
<span class="anchor" id="line-2-67"></span>expr "$word" : ".\(.*\)"</pre><span class="anchor" id="line-1077"></span><p class="line874">The problem is "match" is a keyword. Solution (GNU only) is prefix with a '+' <span class="anchor" id="line-1078"></span><span class="anchor" id="line-1079"></span><p class="line867"><span class="anchor" id="line-1080"></span><span class="anchor" id="line-1081"></span><span class="anchor" id="line-1082"></span><span class="anchor" id="line-1083"></span><pre><span class="anchor" id="line-1-100"></span>word=match
<span class="anchor" id="line-2-68"></span>expr + "$word" : ".\(.*\)"
<span class="anchor" id="line-3-45"></span>atch</pre><span class="anchor" id="line-1084"></span><p class="line862">Or, y'know, stop using <tt class="backtick">expr</tt>.  You can do everything <tt class="backtick">expr</tt> does by using <a href="/BashFAQ/073">Parameter Expansion</a>.  What's that thing up there trying to do?  Remove the first letter of a word?  That can be done in POSIX shells using PE or Substring Expansion: <span class="anchor" id="line-1085"></span><span class="anchor" id="line-1086"></span><p class="line867"><span class="anchor" id="line-1087"></span><span class="anchor" id="line-1088"></span><span class="anchor" id="line-1089"></span><span class="anchor" id="line-1090"></span><span class="anchor" id="line-1091"></span><span class="anchor" id="line-1092"></span><pre><span class="anchor" id="line-1-101"></span>$ word=match
<span class="anchor" id="line-2-69"></span>$ echo "${word#?}"    # PE
<span class="anchor" id="line-3-46"></span>atch
<span class="anchor" id="line-4-24"></span>$ echo "${word:1}"    # SE
<span class="anchor" id="line-5-18"></span>atch</pre><span class="anchor" id="line-1093"></span><p class="line862">Seriously, there's no excuse for using <tt class="backtick">expr</tt> unless you're on Solaris with its non-POSIX-conforming <tt class="backtick">/bin/sh</tt>.  It's an external process, so it's much slower than in-process string manipulation.  And since nobody uses it, nobody understands what it's doing, so your code is obfuscated and hard to maintain. <span class="anchor" id="line-1094"></span><span class="anchor" id="line-1095"></span><p class="line867"><span class="anchor" id="pf40"></span> <span class="anchor" id="line-1096"></span><span class="anchor" id="line-1097"></span><p class="line867">
<h2 id="On_UTF-8_and_Byte-Order_Marks_.28BOM.29">40. On UTF-8 and Byte-Order Marks (BOM)</h2>
<span class="anchor" id="line-1098"></span><p class="line867"><strong>In general:</strong> Unix UTF-8 text does not use BOM. The encoding of plain text is determined by the locale or by mime types or other metadata. While the presence of a BOM would not normally damage a UTF-8 document meant only for reading by humans, it is problematic (often syntactically illegal) in any text file meant to be interpreted by automated processes such as scripts, source code, configuration files, and so on. Files starting with BOM should be considered equally foreign as those with MS-DOS linebreaks. <span class="anchor" id="line-1099"></span><span class="anchor" id="line-1100"></span><p class="line867"><strong>In shell scripting:</strong> 'Where UTF-8 is used transparently in 8-bit environments, the use of a BOM will interfere with any protocol or file format that expects specific ASCII characters at the beginning, such as the use of "#!" of at the beginning of Unix shell scripts.' <a class="http" href="http://unicode.org/faq/utf_bom.html#bom5">http://unicode.org/faq/utf_bom.html#bom5</a> <span class="anchor" id="line-1101"></span><span class="anchor" id="line-1102"></span><p class="line867"><span class="anchor" id="pf41"></span> <span class="anchor" id="line-1103"></span><span class="anchor" id="line-1104"></span><p class="line867">
<h2 id="content.3D.24.28.3Cfile.29">41. content=$(&lt;file)</h2>
<span class="anchor" id="line-1105"></span><p class="line862">There isn't anything wrong with this expression, but you should be aware that command substitutions (all forms: <tt>`...`</tt>, <tt class="backtick">$(...)</tt>, <tt class="backtick">$(&lt;file)</tt>, <tt>`&lt;file`</tt>, and <tt class="backtick">${&nbsp;...;&nbsp;}</tt> (ksh)) remove any trailing newlines. This is often inconsequential or even desirable, but if you must preserve the literal output including any possible trailing newlines, it gets tricky because you have no way of knowing whether the output had them or how many. One ugly but usable workaround is to add a postfix inside the command substitution and remove it on the outside: <span class="anchor" id="line-1106"></span><span class="anchor" id="line-1107"></span><p class="line867"><span class="anchor" id="line-1108"></span><span class="anchor" id="line-1109"></span><span class="anchor" id="line-1110"></span><pre><span class="anchor" id="line-1-102"></span>absolute_dir_path_x=$(readlink -fn -- "$dir_path"; printf x)
<span class="anchor" id="line-2-70"></span>absolute_dir_path=${absolute_dir_path_x%x}</pre><span class="anchor" id="line-1111"></span><p class="line862">A less portable but arguably prettier solution is to use <tt class="backtick">read</tt> with an empty delimiter. <span class="anchor" id="line-1112"></span><span class="anchor" id="line-1113"></span><p class="line867"><span class="anchor" id="line-1114"></span><span class="anchor" id="line-1115"></span><span class="anchor" id="line-1116"></span><pre><span class="anchor" id="line-1-103"></span># Ksh (or bash 4.2+ with lastpipe enabled)
<span class="anchor" id="line-2-71"></span>readlink -fn -- "$dir_path" | IFS= read -rd '' absolute_dir_path</pre><span class="anchor" id="line-1117"></span><p class="line862">The downside to this method is that the <tt class="backtick">read</tt> will always return false unless the command outputs a NUL byte causing only part of the stream to be read. The only way to get the exit status of the command is through <tt class="backtick">PIPESTATUS</tt>. You could also intentionally output a NUL byte to force <tt class="backtick">read</tt> to return true, and use <tt class="backtick">pipefail</tt>. <span class="anchor" id="line-1118"></span><span class="anchor" id="line-1119"></span><p class="line867"><span class="anchor" id="line-1120"></span><span class="anchor" id="line-1121"></span><span class="anchor" id="line-1122"></span><span class="anchor" id="line-1123"></span><pre><span class="anchor" id="line-1-104"></span>set -o pipefail
<span class="anchor" id="line-2-72"></span>{ readlink -fn -- "$dir_path" &amp;&amp; printf '\0'; } | IFS= read -rd '' absolute_dir_path
<span class="anchor" id="line-3-47"></span>set +o pipefail</pre><span class="anchor" id="line-1124"></span><p class="line862">This is somewhat of a portability mess, as Bash supports both <tt class="backtick">pipefail</tt> and <tt class="backtick">PIPESTATUS</tt>, ksh93 supports <tt class="backtick">pipefail</tt> only, and only recent versions of mksh support <tt class="backtick">pipefail</tt>, while earlier versions supported <tt class="backtick">PIPESTATUS</tt> only. Additionally, a bleeding-edge ksh93 version is required in order for <tt class="backtick">read</tt> to stop at the NUL byte. <span class="anchor" id="line-1125"></span><span class="anchor" id="line-1126"></span><p class="line867"><span class="anchor" id="pf42"></span> <span class="anchor" id="line-1127"></span><span class="anchor" id="line-1128"></span><p class="line867">
<h2 id="for_file_in_..2F.2A_.3B_do_if_.5B.5B_.24file_.21.3D_.2A..2A_.5D.5D">42. for file in ./* ; do if [[ $file != *.* ]]</h2>
<span class="anchor" id="line-1129"></span><p class="line862">One way to prevent programs from interpreting filenames passed to them as options is to use pathnames (see <a href="/BashPitfalls#pf3">pitfall #3</a> above). For files under the current directory, names may be prefixed with a relative pathname <tt class="backtick">./</tt>. <span class="anchor" id="line-1130"></span><span class="anchor" id="line-1131"></span><p class="line862">In the case of a pattern like <tt class="backtick">*.*</tt> however, problems can arise because it matches a string of the form <tt class="backtick">./filename</tt>. In a simple case, you can just use the glob directly to generate the desired matches. If however a separate pattern-matching step is required (e.g. the results have been preprocessed and stored in an array, and need to be filtered), it could be solved by taking the prefix into account in the pattern: <tt class="backtick">[[&nbsp;$file&nbsp;!=&nbsp;./*.*&nbsp;]]</tt>, or by stripping the pattern from the match. <span class="anchor" id="line-1132"></span><span class="anchor" id="line-1133"></span><p class="line867"><span class="anchor" id="line-1134"></span><span class="anchor" id="line-1135"></span><span class="anchor" id="line-1136"></span><span class="anchor" id="line-1137"></span><span class="anchor" id="line-1138"></span><span class="anchor" id="line-1139"></span><span class="anchor" id="line-1140"></span><span class="anchor" id="line-1141"></span><span class="anchor" id="line-1142"></span><span class="anchor" id="line-1143"></span><span class="anchor" id="line-1144"></span><span class="anchor" id="line-1145"></span><span class="anchor" id="line-1146"></span><span class="anchor" id="line-1147"></span><span class="anchor" id="line-1148"></span><span class="anchor" id="line-1149"></span><pre><span class="anchor" id="line-1-105"></span># Bash
<span class="anchor" id="line-2-73"></span>shopt -s nullglob
<span class="anchor" id="line-3-48"></span>for path in ./*; do
<span class="anchor" id="line-4-25"></span>    [[ ${path##*/} != *.* ]] &amp;&amp; rm "$path"
<span class="anchor" id="line-5-19"></span>done
<span class="anchor" id="line-6-12"></span>
<span class="anchor" id="line-7-8"></span># Or even better
<span class="anchor" id="line-8-5"></span>for file in *; do
<span class="anchor" id="line-9-5"></span>    [[ $file != *.* ]] &amp;&amp; rm "./$file"
<span class="anchor" id="line-10-4"></span>done
<span class="anchor" id="line-11-3"></span>
<span class="anchor" id="line-12-3"></span># Or better still
<span class="anchor" id="line-13-2"></span>for file in *.*; do
<span class="anchor" id="line-14-1"></span>    rm "./$file"
<span class="anchor" id="line-15-1"></span>done</pre><span class="anchor" id="line-1150"></span><p class="line862">Another possibility is to signal the <em>end of options</em> with a <tt class="backtick">--</tt> argument. (Again, covered in <a href="/BashPitfalls#pf3">#pf3</a>). <span class="anchor" id="line-1151"></span><span class="anchor" id="line-1152"></span><p class="line867"><span class="anchor" id="line-1153"></span><span class="anchor" id="line-1154"></span><span class="anchor" id="line-1155"></span><span class="anchor" id="line-1156"></span><span class="anchor" id="line-1157"></span><pre><span class="anchor" id="line-1-106"></span>shopt -s nullglob
<span class="anchor" id="line-2-74"></span>for file in *; do
<span class="anchor" id="line-3-49"></span>    [[ $file != *.* ]] &amp;&amp; rm -- "$file"
<span class="anchor" id="line-4-26"></span>done</pre><span class="anchor" id="line-1158"></span><p class="line867"><span class="anchor" id="pf43"></span> <span class="anchor" id="line-1159"></span><span class="anchor" id="line-1160"></span><p class="line867">
<h2 id="somecmd_2.3E.261_.3E.3Elogfile">43. somecmd 2&gt;&amp;1 &gt;&gt;logfile</h2>
<span class="anchor" id="line-1161"></span><p class="line862">This is by far the most common mistake involving redirections, typically performed by someone wanting to direct both stdout and stderr to a file or pipe will try this and not understand why stderr is still showing up on their terminal. If you're perplexed by this, you probably don't understand how <a class="http" href="http://wiki.bash-hackers.org/howto/redirection_tutorial">redirections</a> or possibly <a href="/FileDescriptor">file descriptors</a> work to begin with. Redirections are evaluated left-to-right before the command is executed. This semantically incorrect code essentially means: "first redirect standard error to where standard out is currently pointing (the tty), then redirect standard out to logfile". This is backwards. Standard error is already going to the tty. Use the following instead: <span class="anchor" id="line-1162"></span><span class="anchor" id="line-1163"></span><p class="line867"><span class="anchor" id="line-1164"></span><span class="anchor" id="line-1165"></span><pre><span class="anchor" id="line-1-107"></span>somecmd &gt;&gt;logfile 2&gt;&amp;1</pre><span class="anchor" id="line-1166"></span><p class="line862">See <a href="/BashFAQ/055">a more in-depth explanation</a>, <a class="http" href="http://wiki.bash-hackers.org/scripting/copydescriptor">Copy descriptor explained</a>, and <a href="/BashGuide/InputAndOutput#Redirection">BashGuide - redirection</a>. <span class="anchor" id="line-1167"></span><span class="anchor" id="line-1168"></span><p class="line867"><span class="anchor" id="pf44"></span> <span class="anchor" id="line-1169"></span><span class="anchor" id="line-1170"></span><p class="line867">
<h2 id="cmd.3B_.28.28_.21_.24.3F_.29.29_.7C.7C_die">44. cmd; (( ! $? )) || die</h2>
<span class="anchor" id="line-1171"></span><p class="line867"><tt class="backtick">$?</tt> is only required if you need to retrieve the exact status of the previous command. If you only need to test for success or failure (any non-zero status), just test the command directly. e.g.: <span class="anchor" id="line-1172"></span><span class="anchor" id="line-1173"></span><p class="line867"><span class="anchor" id="line-1174"></span><span class="anchor" id="line-1175"></span><span class="anchor" id="line-1176"></span><span class="anchor" id="line-1177"></span><pre><span class="anchor" id="line-1-108"></span>if cmd; then
<span class="anchor" id="line-2-75"></span>    ...
<span class="anchor" id="line-3-50"></span>fi</pre><span class="anchor" id="line-1178"></span><p class="line874">Checking an exit status against a list of alternatives might follow a pattern like this: <span class="anchor" id="line-1179"></span><span class="anchor" id="line-1180"></span><p class="line867"><span class="anchor" id="line-1181"></span><span class="anchor" id="line-1182"></span><span class="anchor" id="line-1183"></span><span class="anchor" id="line-1184"></span><span class="anchor" id="line-1185"></span><span class="anchor" id="line-1186"></span><span class="anchor" id="line-1187"></span><span class="anchor" id="line-1188"></span><span class="anchor" id="line-1189"></span><span class="anchor" id="line-1190"></span><span class="anchor" id="line-1191"></span><span class="anchor" id="line-1192"></span><span class="anchor" id="line-1193"></span><span class="anchor" id="line-1194"></span><span class="anchor" id="line-1195"></span><pre><span class="anchor" id="line-1-109"></span>cmd
<span class="anchor" id="line-2-76"></span>status=$?
<span class="anchor" id="line-3-51"></span>case $status in
<span class="anchor" id="line-4-27"></span>    0)
<span class="anchor" id="line-5-20"></span>        echo success &gt;&amp;2
<span class="anchor" id="line-6-13"></span>        ;;
<span class="anchor" id="line-7-9"></span>    1)
<span class="anchor" id="line-8-6"></span>        echo 'Must supply a parameter, exiting.' &gt;&amp;2
<span class="anchor" id="line-9-6"></span>        exit 1
<span class="anchor" id="line-10-5"></span>        ;;
<span class="anchor" id="line-11-4"></span>    *)
<span class="anchor" id="line-12-4"></span>        echo "Unknown error $status, exiting." &gt;&amp;2
<span class="anchor" id="line-13-3"></span>        exit "$status"
<span class="anchor" id="line-14-2"></span>esac</pre><span class="anchor" id="line-1196"></span><p class="line867"><span class="anchor" id="pf45"></span> <span class="anchor" id="line-1197"></span><span class="anchor" id="line-1198"></span><p class="line867">
<h2 id="y.3D.24.28.28_array.5B.24x.5D_.29.29">45. y=$(( array[$x] ))</h2>
<span class="anchor" id="line-1199"></span><p class="line862">The code given to an arithmetic expansion or compound command undergoes a pass of expansions and substitutions prior to evaluation. <em>It is the text generated by these initial expansions that is ultimately evaluated as an arithmetic expression.</em> This must be handled correctly or unintended code execution can easily result. <span class="anchor" id="line-1200"></span><span class="anchor" id="line-1201"></span><p class="line874">Here, an expression is stitched together by expanding one code fragment into another. <span class="anchor" id="line-1202"></span><span class="anchor" id="line-1203"></span><p class="line867"><span class="anchor" id="line-1204"></span><span class="anchor" id="line-1205"></span><span class="anchor" id="line-1206"></span><span class="anchor" id="line-1207"></span><pre><span class="anchor" id="line-1-110"></span>$ x='$(date &gt;&amp;2)'        # redirection is just so we can see everything happen
<span class="anchor" id="line-2-77"></span>$ y=$((array["$x"]))       # Quotes don't help. The array doesn't even have to exist
<span class="anchor" id="line-3-52"></span>Mon Jun  2 10:49:08 EDT 2014</pre><span class="anchor" id="line-1208"></span><p class="line862">The arithmetic processor needs to get a reference to this array variable in bash's internal symbol table, so it passes <tt class="backtick">array[$(date&nbsp;&gt;&amp;2)]</tt> to a lookup function (just like e.g. <tt class="backtick">read</tt> or <tt class="backtick">printf&nbsp;-v</tt> do with variable names passed as arguments) which in turn expands the command substitution to resolve the index. <span class="anchor" id="line-1209"></span><span class="anchor" id="line-1210"></span><p class="line867"><small>(For numeric indexed arrays, the lookup function next evaluates the expanded text of the index as an arithmetic expression. Consequently, mutually recursive variable lookups and arithmetic expansions can occur to any depth (up to Bash's defined limit), any of which can produce unintended side-effects.)</small> <span class="anchor" id="line-1211"></span><span class="anchor" id="line-1212"></span><p class="line862">Most of the time, there is no need to use any kind of expansion within an arithmetic expansion. Use variable names directly in the expression (no <tt class="backtick">$</tt>) wherever possible (i.e. except for positional parameters and POSIX "special variables"). If you validate variables before using them and guarantee that no expansion generates anything other than a numeric literal then most issues are automatically avoided. <span class="anchor" id="line-1213"></span><span class="anchor" id="line-1214"></span><p class="line874">Escape any expansions to pass them into the expression without expanding them first: <span class="anchor" id="line-1215"></span><span class="anchor" id="line-1216"></span><p class="line867"><span class="anchor" id="line-1217"></span><span class="anchor" id="line-1218"></span><span class="anchor" id="line-1219"></span><span class="anchor" id="line-1220"></span><span class="anchor" id="line-1221"></span><span class="anchor" id="line-1222"></span><span class="anchor" id="line-1223"></span><span class="anchor" id="line-1224"></span><span class="anchor" id="line-1225"></span><pre><span class="anchor" id="line-1-111"></span># Typical task reading some columns into an associative array.
<span class="anchor" id="line-2-78"></span>typeset -A arr
<span class="anchor" id="line-3-53"></span>printf -v offset '%(%s)T' -1
<span class="anchor" id="line-4-28"></span>
<span class="anchor" id="line-5-21"></span>while IFS=' ' read -r x y; do
<span class="anchor" id="line-6-14"></span>    [[ $x $y == +([0-9]) +([0-9]) ]] # validate input (see next pitfall)
<span class="anchor" id="line-7-10"></span>    (( arr[\$(date -d "@$x" +%F)] = y - offset )) # Escaped substitution passes the entire expression literally.
<span class="anchor" id="line-8-7"></span>done</pre><span class="anchor" id="line-1226"></span><p class="line862">Another option is to use <tt class="backtick">let</tt> with single-quoted arguments. <tt class="backtick">((expr))</tt> is equivalent to <tt class="backtick">let&nbsp;"expr"</tt> (double-quoted args). <span class="anchor" id="line-1227"></span><span class="anchor" id="line-1228"></span><p class="line867"><span class="anchor" id="pf46"></span> <span class="anchor" id="line-1229"></span><span class="anchor" id="line-1230"></span><p class="line867">
<h2 id="read_num.3B_echo_.24.28.28num.2B-1.29.29">46. read num; echo $((num+1))</h2>
<span class="anchor" id="line-1231"></span><p class="line862">Always validate your input (see <a href="/BashFAQ/054">BashFAQ/054</a>) before using num in an arithmetic context as it allows code injection. <span class="anchor" id="line-1232"></span><span class="anchor" id="line-1233"></span><p class="line867"><span class="anchor" id="line-1234"></span><span class="anchor" id="line-1235"></span><span class="anchor" id="line-1236"></span><span class="anchor" id="line-1237"></span><pre><span class="anchor" id="line-1-112"></span>$ echo 'a[$(echo injection &gt;&amp;2)]' | bash -c 'read num; echo $((num+1))'
<span class="anchor" id="line-2-79"></span>injection
<span class="anchor" id="line-3-54"></span>1</pre><span class="anchor" id="line-1238"></span><p class="line867"><span class="anchor" id="pf47"></span> <span class="anchor" id="line-1239"></span><span class="anchor" id="line-1240"></span><p class="line867">
<h2 id="IFS.3D.2C_read_-ra_fields_.3C.3C.3C_.22.24csv_line.22">47. IFS=, read -ra fields &lt;&lt;&lt; "$csv_line"</h2>
<span class="anchor" id="line-1241"></span><p class="line862">Unbelievable as it may seem, POSIX requires the treatment of <a href="/IFS">IFS</a> as a field <em>terminator</em>, rather than a field <em>separator</em>.  What this means in our example is that if there's an empty field at the end of the input line, it will be discarded: <span class="anchor" id="line-1242"></span><span class="anchor" id="line-1243"></span><p class="line867"><span class="anchor" id="line-1244"></span><span class="anchor" id="line-1245"></span><span class="anchor" id="line-1246"></span><span class="anchor" id="line-1247"></span><pre><span class="anchor" id="line-1-113"></span>$ IFS=, read -ra fields &lt;&lt;&lt; "a,b,"
<span class="anchor" id="line-2-80"></span>$ declare -p fields
<span class="anchor" id="line-3-55"></span>declare -a fields='([0]="a" [1]="b")'</pre><span class="anchor" id="line-1248"></span><p class="line874">Where did the empty field go?  It was eaten for historical reasons ("because it's always been that way").  This behavior is not unique to bash; all conformant shells do it.  A non-empty field is properly scanned: <span class="anchor" id="line-1249"></span><span class="anchor" id="line-1250"></span><p class="line867"><span class="anchor" id="line-1251"></span><span class="anchor" id="line-1252"></span><span class="anchor" id="line-1253"></span><span class="anchor" id="line-1254"></span><pre><span class="anchor" id="line-1-114"></span>$ IFS=, read -ra fields &lt;&lt;&lt; "a,b,c"
<span class="anchor" id="line-2-81"></span>$ declare -p fields
<span class="anchor" id="line-3-56"></span>declare -a fields='([0]="a" [1]="b" [2]="c")'</pre><span class="anchor" id="line-1255"></span><p class="line874">So, how do we work around this nonsense?  As it turns out, appending an IFS character to the end of the input string will force the scanning to work.  If there was a trailing empty field, the extra IFS character "terminates" it so that it gets scanned.  If there was a trailing non-empty field, the IFS character creates a new, empty field that gets dropped. <span class="anchor" id="line-1256"></span><span class="anchor" id="line-1257"></span><p class="line867"><span class="anchor" id="line-1258"></span><span class="anchor" id="line-1259"></span><span class="anchor" id="line-1260"></span><span class="anchor" id="line-1261"></span><span class="anchor" id="line-1262"></span><pre><span class="anchor" id="line-1-115"></span>$ input="a,b,"
<span class="anchor" id="line-2-82"></span>$ IFS=, read -ra fields &lt;&lt;&lt; "$input,"
<span class="anchor" id="line-3-57"></span>$ declare -p fields
<span class="anchor" id="line-4-29"></span>declare -a fields='([0]="a" [1]="b" [2]="")'</pre><span class="anchor" id="line-1263"></span><p class="line867"><span class="anchor" id="pf48"></span> <span class="anchor" id="line-1264"></span><span class="anchor" id="line-1265"></span><p class="line867">
<h2 id="export_CDPATH.3D.:.2BAH4-.2FmyProject">48. export CDPATH=.:~/myProject</h2>
<span class="anchor" id="line-1266"></span><p class="line874">Do not export CDPATH. <span class="anchor" id="line-1267"></span><span class="anchor" id="line-1268"></span><p class="line862">Setting CDPATH in .bashrc is not an issue, but exporting it will cause any bash or sh script you run, that happen to use <tt class="backtick">cd</tt>, to potentially change behaviour. <span class="anchor" id="line-1269"></span><span class="anchor" id="line-1270"></span><p class="line874">There are two problems. A script that does the following: <span class="anchor" id="line-1271"></span><span class="anchor" id="line-1272"></span><p class="line867"><span class="anchor" id="line-1273"></span><span class="anchor" id="line-1274"></span><span class="anchor" id="line-1275"></span><pre><span class="anchor" id="line-1-116"></span>cd some/dir || exit
<span class="anchor" id="line-2-83"></span>cmd to be run in some/dir</pre><span class="anchor" id="line-1276"></span><p class="line862">may change directory to <tt class="backtick">~/myProject/some/dir</tt> instead of <tt class="backtick">./some/dir</tt>, depending on what directories exist at the time. So the <tt class="backtick">cd</tt> may succeed and take the script to the wrong directory, with potentially harmful effects of the following commands which now run in a different directory than intended. <span class="anchor" id="line-1277"></span><span class="anchor" id="line-1278"></span><p class="line862">The second problem is when <tt class="backtick">cd</tt> is run in a context where the output is captured: <span class="anchor" id="line-1279"></span><span class="anchor" id="line-1280"></span><p class="line867"><span class="anchor" id="line-1281"></span><span class="anchor" id="line-1282"></span><pre><span class="anchor" id="line-1-117"></span>output=$(cd some/dir &amp;&amp; some command)</pre><span class="anchor" id="line-1283"></span><p class="line862">As a side-effect when CDPATH is set, <tt class="backtick">cd</tt> will output something like <tt class="backtick">/home/user/some/dir</tt> to stdout to indicate that it found a directory through CDPATH, which in turn will end up in the output variable along with the intended output of <tt class="backtick">some&nbsp;command</tt>. <span class="anchor" id="line-1284"></span><span class="anchor" id="line-1285"></span><p class="line862">A script can make itself immune to a CDPATH inherited from the environment by always prepending <tt class="backtick">./</tt> to relative paths, or run <tt class="backtick">unset&nbsp;CDPATH</tt> at the start of the script, but don't assume every scripter has taken this pitfall into account, so don't export CDPATH. <span class="anchor" id="line-1286"></span><span class="anchor" id="line-1287"></span><p class="line867"><span class="anchor" id="pf49"></span> <span class="anchor" id="line-1288"></span><span class="anchor" id="line-1289"></span><p class="line867">
<h2 id="OIFS.3D.22.24IFS.22.3B_....3B_IFS.3D.22.24OIFS.22">49. OIFS="$IFS"; ...; IFS="$OIFS"</h2>
<span class="anchor" id="line-1290"></span><p class="line862">Directly assigning a variable's value to a temporary variable isn't alone enough to restore its state. The assignment will always result in a <em>set</em> but <em>empty</em> temporary variable even if the initial variable was unset. This is a particular problem for IFS because an <em>empty</em> IFS has a completely different meaning from an <em>unset</em> IFS, and setting IFS to a temporary value for a command or two is a common requirement. <span class="anchor" id="line-1291"></span><span class="anchor" id="line-1292"></span><p class="line874">An easy workaround is to designate a prefix to distinguish set from unset vars, then strip it when finished. <span class="anchor" id="line-1293"></span><span class="anchor" id="line-1294"></span><p class="line867"><span class="anchor" id="line-1295"></span><span class="anchor" id="line-1296"></span><span class="anchor" id="line-1297"></span><span class="anchor" id="line-1298"></span><pre><span class="anchor" id="line-1-118"></span>oIFS=${IFS+_${IFS}}
<span class="anchor" id="line-2-84"></span>IFS=/; echo "${array[*]}"
<span class="anchor" id="line-3-58"></span>${oIFS:+'false'} unset -v IFS || IFS=${oIFS#_}</pre><span class="anchor" id="line-1299"></span><p class="line874">A local variable is usually preferable when possible. <span class="anchor" id="line-1300"></span><span class="anchor" id="line-1301"></span><p class="line867"><span class="anchor" id="line-1302"></span><span class="anchor" id="line-1303"></span><span class="anchor" id="line-1304"></span><span class="anchor" id="line-1305"></span><span class="anchor" id="line-1306"></span><span class="anchor" id="line-1307"></span><pre><span class="anchor" id="line-1-119"></span>f() {
<span class="anchor" id="line-2-85"></span>  local IFS
<span class="anchor" id="line-3-59"></span>  IFS=/; echo "${array[*]}"
<span class="anchor" id="line-4-30"></span>}
<span class="anchor" id="line-5-22"></span>f</pre><span class="anchor" id="line-1308"></span><p class="line874">Subshells are another possibility. <span class="anchor" id="line-1309"></span><span class="anchor" id="line-1310"></span><p class="line867"><span class="anchor" id="line-1311"></span><span class="anchor" id="line-1312"></span><pre><span class="anchor" id="line-1-120"></span>( IFS=/; echo "${array[*]}" )</pre><span class="anchor" id="line-1313"></span><p class="line867"><span class="anchor" id="pf50"></span> <span class="anchor" id="line-1314"></span><span class="anchor" id="line-1315"></span><p class="line867">
<h2 id="hosts.3D.28_.24.28aws_....29_.29">50. hosts=( $(aws ...) )</h2>
<span class="anchor" id="line-1316"></span><p class="line862">It is not safe to populate an array with a raw <tt class="backtick">$(...)</tt> <a href="/CommandSubstitution">CommandSubstitution</a>.  The output of the command undergoes word splitting (on <em>all</em> whitespace, even ones that are inside quotes) and then <a href="/glob">globbing</a>.  If there's a word like <tt class="backtick">*</tt> or <tt class="backtick">eh?</tt> or <tt class="backtick">[abc]</tt> in the result, it will be expanded based on filenames in the current working directory. <span class="anchor" id="line-1317"></span><span class="anchor" id="line-1318"></span><p class="line874">To select a replacement, you need to know whether the command writes its output on a single line, or multiple lines.  If it's a single line: <span class="anchor" id="line-1319"></span><span class="anchor" id="line-1320"></span><p class="line867"><span class="anchor" id="line-1321"></span><span class="anchor" id="line-1322"></span><pre><span class="anchor" id="line-1-121"></span>read -ra hosts &lt; &lt;(aws ...)</pre><span class="anchor" id="line-1323"></span><p class="line874">If it's multiple lines (and you're targeting bash 4.0 or later): <span class="anchor" id="line-1324"></span><span class="anchor" id="line-1325"></span><p class="line867"><span class="anchor" id="line-1326"></span><span class="anchor" id="line-1327"></span><pre><span class="anchor" id="line-1-122"></span>readarray -t hosts &lt; &lt;(aws ...)</pre><span class="anchor" id="line-1328"></span><p class="line862">If it's multiple lines (and you want compatibility with bash 3.x, <em>or</em> want your command's exit status to be reflected in success or failure of the <tt class="backtick">read</tt> operation without depending on behavior only available in bash 4.4 and newer): <span class="anchor" id="line-1329"></span><span class="anchor" id="line-1330"></span><p class="line867"><span class="anchor" id="line-1331"></span><span class="anchor" id="line-1332"></span><pre><span class="anchor" id="line-1-123"></span>IFS=$'\n' read -r -d '' -a hosts &lt; &lt;(aws ... &amp;&amp; printf '\0')</pre><span class="anchor" id="line-1333"></span><p class="line862">This will prevent globbing.  It still won't help you if you needed to avoid splitting on quoted whitespace, but unfortunately <em>nothing</em> bash can do handles that case.  For generalized CSV (comma-separated value) file handling, you really need to switch to a language that has a dedicated CSV input library. <span class="anchor" id="line-1334"></span><span class="anchor" id="line-1335"></span><p class="line867"><span class="anchor" id="pf51"></span> <span class="anchor" id="line-1336"></span><span class="anchor" id="line-1337"></span><p class="line867">
<h2 id="Non-atomic_writes_with_xargs_-P">51. Non-atomic writes with xargs -P</h2>
<span class="anchor" id="line-1338"></span><p class="line862">GNU <tt class="backtick">xargs</tt> supports running multiple jobs in parallel. <tt class="backtick">-P&nbsp;n</tt> where <strong>n</strong> is the number of jobs to run in parallel. <span class="anchor" id="line-1339"></span><span class="anchor" id="line-1340"></span><p class="line867"><span class="anchor" id="line-1341"></span><span class="anchor" id="line-1342"></span><span class="anchor" id="line-1343"></span><pre><span class="anchor" id="line-1-124"></span>seq 100 | xargs -n1 -P10 echo "$a" | grep 5
<span class="anchor" id="line-2-86"></span>seq 100 | xargs -n1 -P10 echo "$a" &gt; myoutput.txt</pre><span class="anchor" id="line-1344"></span><p class="line862">This will work fine for many situations but has a deceptive flaw: If <tt class="backtick">$a</tt> contains more than 8192 characters (the limit depends on platform and version), the <tt class="backtick">echo</tt> may not be atomic (it may be split into multiple <tt class="backtick">write()</tt> calls), and there is a risk that two lines will be mixed. <span class="anchor" id="line-1345"></span><span class="anchor" id="line-1346"></span><p class="line867"><span class="anchor" id="line-1347"></span><span class="anchor" id="line-1348"></span><span class="anchor" id="line-1349"></span><span class="anchor" id="line-1350"></span><span class="anchor" id="line-1351"></span><span class="anchor" id="line-1352"></span><pre><span class="anchor" id="line-1-125"></span>$ perl -e 'print "a"x10000, "\n"' &gt; foo
<span class="anchor" id="line-2-87"></span>$ strace -e write bash -c 'read -r foo &lt; foo; echo "$foo"' &gt;/dev/null
<span class="anchor" id="line-3-60"></span>write(1, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"..., 8192) = 8192
<span class="anchor" id="line-4-31"></span>write(1, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"..., 1809) = 1809
<span class="anchor" id="line-5-23"></span>+++ exited with 0 +++</pre><span class="anchor" id="line-1353"></span><p class="line862">Obviously the same issue arises if there are multiple calls to <tt class="backtick">echo</tt> or <tt class="backtick">printf</tt>: <span class="anchor" id="line-1354"></span><span class="anchor" id="line-1355"></span><p class="line867"><span class="anchor" id="line-1356"></span><span class="anchor" id="line-1357"></span><span class="anchor" id="line-1358"></span><span class="anchor" id="line-1359"></span><span class="anchor" id="line-1360"></span><span class="anchor" id="line-1361"></span><span class="anchor" id="line-1362"></span><span class="anchor" id="line-1363"></span><span class="anchor" id="line-1364"></span><span class="anchor" id="line-1365"></span><span class="anchor" id="line-1366"></span><pre><span class="anchor" id="line-1-126"></span>slowprint() {
<span class="anchor" id="line-2-88"></span>  printf 'Start-%s ' "$1"
<span class="anchor" id="line-3-61"></span>  sleep "$1"
<span class="anchor" id="line-4-32"></span>  printf '%s-End\n' "$1"
<span class="anchor" id="line-5-24"></span>}
<span class="anchor" id="line-6-15"></span>export -f slowprint
<span class="anchor" id="line-7-11"></span>seq 10 | xargs -n1 -I {} -P4 bash -c "slowprint {}"
<span class="anchor" id="line-8-8"></span># Compare to no parallelization
<span class="anchor" id="line-9-7"></span>seq 10 | xargs -n1 -I {} bash -c "slowprint {}"
<span class="anchor" id="line-10-6"></span># Be sure to see the warnings in the next Pitfall!</pre><span class="anchor" id="line-1367"></span><p class="line862">Outputs from the parallel jobs are mixed together, because each job consists of two (or more) separate <tt class="backtick">write()</tt> calls. <span class="anchor" id="line-1368"></span><span class="anchor" id="line-1369"></span><p class="line874">If you need the outputs unmixed, it is therefore recommended to use a tool that guarantees output will be serialized (such as GNU Parallel). <span class="anchor" id="line-1370"></span><span class="anchor" id="line-1371"></span><p class="line862">For further details see <a class="https" href="https://gist.github.com/ole-tange/88ae153797748b3618e2433377e2870a">a demonstration of the mixing problem</a>. <span class="anchor" id="line-1372"></span><span class="anchor" id="line-1373"></span><p class="line867"><span class="anchor" id="pf52"></span> <span class="anchor" id="line-1374"></span><span class="anchor" id="line-1375"></span><p class="line867">
<h2 id="find_._-exec_sh_-c_.27echo_.7B.7D.27_.2BAFw.3B">52. find . -exec sh -c 'echo {}' \;</h2>
<span class="anchor" id="line-1376"></span><p class="line862">This command contains a <a href="/CodeInjection">CodeInjection</a> vulnerability.  The filename that is found by <tt class="backtick">find</tt> is injected into a shell command and parsed by <tt class="backtick">sh</tt>.  If the filename contains shell metacharacters like <tt class="backtick">;</tt> or <tt class="backtick">$(&nbsp;...&nbsp;)</tt> then the filename may be <em>executed as code</em> by `sh'. <span class="anchor" id="line-1377"></span><span class="anchor" id="line-1378"></span><p class="line862">The "slowprint" example in the previous Pitfall would have been a <a href="/CodeInjection">CodeInjection</a> bug if the input weren't guaranteed to be integers. <span class="anchor" id="line-1379"></span><span class="anchor" id="line-1380"></span><p class="line862">To be more precise, <a class="http" href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html#tag_20_47">POSIX find</a> does not specify whether an argument which contains <em>more than</em> just <tt class="backtick">{}</tt> is expanded.  GNU <tt class="backtick">find</tt> allows this <a href="/CodeInjection">CodeInjection</a> to occur.  Other implementations choose a safer path: <span class="anchor" id="line-1381"></span><span class="anchor" id="line-1382"></span><p class="line867"><span class="anchor" id="line-1383"></span><span class="anchor" id="line-1384"></span><span class="anchor" id="line-1385"></span><span class="anchor" id="line-1386"></span><span class="anchor" id="line-1387"></span><pre><span class="anchor" id="line-1-127"></span># uname -a
<span class="anchor" id="line-2-89"></span>HP-UX imadev B.10.20 A 9000/785 2008897791 two-user license
<span class="anchor" id="line-3-62"></span># find /dev/null -exec sh -c 'echo {}' \;
<span class="anchor" id="line-4-33"></span>{}</pre><span class="anchor" id="line-1388"></span><p class="line862">The correct approach is to <em>separate</em> the filename argument from the script argument: <span class="anchor" id="line-1389"></span><span class="anchor" id="line-1390"></span><p class="line867"><span class="anchor" id="line-1391"></span><span class="anchor" id="line-1392"></span><pre><span class="anchor" id="line-1-128"></span>find . -exec sh -c 'echo "$1"' x {} \;</pre><span class="anchor" id="line-1393"></span><p class="line867"><span class="anchor" id="pf53"></span> <span class="anchor" id="line-1394"></span><span class="anchor" id="line-1395"></span><p class="line867">
<h2 id="sudo_mycmd_.3E_.2Fmyfile">53. sudo mycmd &gt; /myfile</h2>
<span class="anchor" id="line-1396"></span><p class="line867"><a href="/Redirection">Redirection</a> is done <em>before</em> the command is executed.  Usually that doesn't matter, but with <tt class="backtick">sudo</tt> we have a command being executed as a different user than the redirection. <span class="anchor" id="line-1397"></span><span class="anchor" id="line-1398"></span><p class="line862">If the redirection must be executed with <tt class="backtick">sudo</tt>-granted privileges, then you need a wrapper: <span class="anchor" id="line-1399"></span><span class="anchor" id="line-1400"></span><p class="line867"><span class="anchor" id="line-1401"></span><span class="anchor" id="line-1402"></span><pre><span class="anchor" id="line-1-129"></span>sudo sh -c 'mycmd &gt; /myfile'</pre><span class="anchor" id="line-1403"></span><p class="line862">Instead of a wrapper you can use <tt class="backtick">tee</tt>: <span class="anchor" id="line-1404"></span><span class="anchor" id="line-1405"></span><p class="line867"><span class="anchor" id="line-1406"></span><span class="anchor" id="line-1407"></span><pre><span class="anchor" id="line-1-130"></span>mycmd | sudo tee /myfile &gt;/dev/null</pre><span class="anchor" id="line-1408"></span><p class="line862">This may be easier to write if <tt class="backtick">mycmd</tt> has a lot of quoting. <span class="anchor" id="line-1409"></span><span class="anchor" id="line-1410"></span><p class="line867"><span class="anchor" id="pf54"></span> <span class="anchor" id="line-1411"></span><span class="anchor" id="line-1412"></span><p class="line867">
<h2 id="sudo_ls_.2Ffoo.2F.2A">54. sudo ls /foo/*</h2>
<span class="anchor" id="line-1413"></span><p class="line862">This is very similar to the previous pitfall.  <a href="/glob">Globbing</a> is also done <em>before</em> the command is executed.  If the directory isn't readable by your normal user privileges, then you may need the globbing to be done in a shell that has the <tt class="backtick">sudo</tt>-granted privileges: <span class="anchor" id="line-1414"></span><span class="anchor" id="line-1415"></span><p class="line867"><span class="anchor" id="line-1416"></span><span class="anchor" id="line-1417"></span><pre><span class="anchor" id="line-1-131"></span>sudo sh -c 'ls /foo/*'</pre><span class="anchor" id="line-1418"></span><p class="line867"><span class="anchor" id="pf55"></span> <span class="anchor" id="line-1419"></span><span class="anchor" id="line-1420"></span><p class="line867">
<h2 id="myprogram_2.3E.26-">55. myprogram 2&gt;&amp;-</h2>
<span class="anchor" id="line-1421"></span><p class="line867"><strong>Do not</strong> close stdin, stdout or stderr as a "shorthand" for redirecting to <tt class="backtick">/dev/null</tt>.  Write it out correctly. <span class="anchor" id="line-1422"></span><span class="anchor" id="line-1423"></span><p class="line867"><span class="anchor" id="line-1424"></span><span class="anchor" id="line-1425"></span><pre><span class="anchor" id="line-1-132"></span>myprogram 2&gt;/dev/null</pre><span class="anchor" id="line-1426"></span><p class="line862">Why?  Consider what happens when your program tries to write an error message to stderr.  If stderr has been redirected to <tt class="backtick">/dev/null</tt>, the write succeeds, and your program is free to carry on, secure in the knowledge that it has diligently reported the error condition. <span class="anchor" id="line-1427"></span><span class="anchor" id="line-1428"></span><p class="line862">But if stderr has been <em>closed</em>, then the write will fail.  At that point, your program may do something unpredictable.  It may carry on and ignore the failure, or it may immediately exit, considering the execution environment so broken that it cannot safely continue.  Or whatever else the programmer decided the program should do when its world has become a dystopian hell. <span class="anchor" id="line-1429"></span><span class="anchor" id="line-1430"></span><p class="line862">All programs are assured that stdin, stdout and stderr will <em>exist</em> and will be readable/writable in an appropriate and reasonable manner.  By closing one of them, you have violated your promise to this program.  This is not acceptable. <span class="anchor" id="line-1431"></span><span class="anchor" id="line-1432"></span><p class="line874">Of course, an even better solution would be to actually log the errors somewhere, so you can go back and read them and figure out what's wrong. <span class="anchor" id="line-1433"></span><span class="anchor" id="line-1434"></span><p class="line867"><span class="anchor" id="pf56"></span> <span class="anchor" id="line-1435"></span><span class="anchor" id="line-1436"></span><p class="line867">
<h2 id="Using_xargs_without_-0">56. Using xargs without -0</h2>
<span class="anchor" id="line-1437"></span><p class="line867"><tt class="backtick">xargs</tt> splits on whitespace. This is unfortunate because whitespace is allowed in filenames and commonly used by GUI users. <tt class="backtick">xargs</tt> also treats <tt class="backtick">'</tt> and <tt class="backtick">"</tt> specially, which can also lead to problems: <span class="anchor" id="line-1438"></span><span class="anchor" id="line-1439"></span><p class="line867"><span class="anchor" id="line-1440"></span><span class="anchor" id="line-1441"></span><span class="anchor" id="line-1442"></span><span class="anchor" id="line-1443"></span><span class="anchor" id="line-1444"></span><pre><span class="anchor" id="line-1-133"></span>touch Dad\'s\ \"famous\"\ 1\'\ pizza.txt
<span class="anchor" id="line-2-90"></span>touch Dad\'s\ 12\"\ records.txt
<span class="anchor" id="line-3-63"></span>touch 2\"x1\'\ wood.txt
<span class="anchor" id="line-4-34"></span>touch 2\"x4\"\ wood.txt</pre><span class="anchor" id="line-1445"></span><p class="line862">Here <tt class="backtick">xargs</tt> warns: <span class="anchor" id="line-1446"></span><span class="anchor" id="line-1447"></span><p class="line867"><span class="anchor" id="line-1448"></span><span class="anchor" id="line-1449"></span><span class="anchor" id="line-1450"></span><span class="anchor" id="line-1451"></span><pre><span class="anchor" id="line-1-134"></span># Do not do this
<span class="anchor" id="line-2-91"></span>$ find . -type f | xargs wc
<span class="anchor" id="line-3-64"></span>xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option</pre><span class="anchor" id="line-1452"></span><p class="line862">Here <tt class="backtick">xargs</tt> does not warn at all: <span class="anchor" id="line-1453"></span><span class="anchor" id="line-1454"></span><p class="line867"><span class="anchor" id="line-1455"></span><span class="anchor" id="line-1456"></span><span class="anchor" id="line-1457"></span><span class="anchor" id="line-1458"></span><span class="anchor" id="line-1459"></span><pre><span class="anchor" id="line-1-135"></span># Do not do this
<span class="anchor" id="line-2-92"></span>echo * | xargs wc
<span class="anchor" id="line-3-65"></span>find *famous* -type f | xargs wc
<span class="anchor" id="line-4-35"></span>find *4* -type f | xargs wc</pre><span class="anchor" id="line-1460"></span><p class="line862">Instead use <tt class="backtick">xargs&nbsp;-0</tt>: <span class="anchor" id="line-1461"></span><span class="anchor" id="line-1462"></span><p class="line867"><span class="anchor" id="line-1463"></span><span class="anchor" id="line-1464"></span><span class="anchor" id="line-1465"></span><span class="anchor" id="line-1466"></span><span class="anchor" id="line-1467"></span><pre><span class="anchor" id="line-1-136"></span># Do this instead
<span class="anchor" id="line-2-93"></span>printf '%s\0' * | xargs -0 wc
<span class="anchor" id="line-3-66"></span>find . -type f -name '*famous*' -print0 | xargs -0 wc
<span class="anchor" id="line-4-36"></span>find . -type f -name '*4*' -exec wc {} +</pre><span class="anchor" id="line-1468"></span><p class="line862">If using <tt class="backtick">-0</tt> is not simple, an alternative is to use GNU Parallel, which splits on \n. And while \n is also allowed in filenames they never occur unless your users are malicious. In any case: <strong>If</strong> you use <tt class="backtick">xargs</tt> without <tt class="backtick">-0</tt> put a comment in your code explaining why that is safe in your particular situation. <span class="anchor" id="line-1469"></span><span class="anchor" id="line-1470"></span><p class="line867"><span class="anchor" id="pf57"></span> <span class="anchor" id="line-1471"></span><span class="anchor" id="line-1472"></span><p class="line867">
<h2 id="unset_a.5B0.5D">57. unset a[0]</h2>
<span class="anchor" id="line-1473"></span><p class="line862">When passing an <a href="/BashFAQ/005">indexed array element</a> to <tt class="backtick">unset</tt>, it needs to be quoted.  Otherwise, it may be treated as a <a href="/glob">glob</a>, and expanded against the files in the current directory.  If there happens to be a file named <tt class="backtick">a0</tt> then the glob is expanded to <tt class="backtick">a0</tt> and you end up executing <tt class="backtick">unset&nbsp;a0</tt>. <span class="anchor" id="line-1474"></span><span class="anchor" id="line-1475"></span><p class="line867"><span class="anchor" id="line-1476"></span><span class="anchor" id="line-1477"></span><pre><span class="anchor" id="line-1-137"></span>unset 'a[0]'     # Always quote indexed array elements when unsetting.</pre><span class="anchor" id="line-1478"></span><p class="line867"><span class="anchor" id="pf58"></span> <span class="anchor" id="line-1479"></span><span class="anchor" id="line-1480"></span><p class="line867">
<h2 id="month.3D.24.28date_.2B-.25m.29.3B_day.3D.24.28date_.2B-.25d.29">58. month=$(date +%m); day=$(date +%d)</h2>
<span class="anchor" id="line-1481"></span><p class="line862">Calling <tt class="backtick">date</tt> multiple times is a bad idea.  Imagine what happens if the first call occurs a millisecond before midnight on April 30, and the second call occurs a millisecond after midnight on May 1.  You would end up with month=04 and day=01. <span class="anchor" id="line-1482"></span><span class="anchor" id="line-1483"></span><p class="line862">It's better to call date <em>one</em> time, retrieving all of the fields you want in a single invocation. <span class="anchor" id="line-1484"></span><span class="anchor" id="line-1485"></span><p class="line874">A common idiom for that: <span class="anchor" id="line-1486"></span><span class="anchor" id="line-1487"></span><p class="line867"><span class="anchor" id="line-1488"></span><span class="anchor" id="line-1489"></span><pre><span class="anchor" id="line-1-138"></span>eval "$(date +'month=%m day=%d year=%Y dayname="%A" monthname="%B"')"</pre><span class="anchor" id="line-1490"></span><p class="line862">Or with bash's (4.2 or above) <tt class="backtick">printf</tt> builtin: <span class="anchor" id="line-1491"></span><span class="anchor" id="line-1492"></span><p class="line867"><span class="anchor" id="line-1493"></span><span class="anchor" id="line-1494"></span><span class="anchor" id="line-1495"></span><pre><span class="anchor" id="line-1-139"></span>printf -v d '%(month=%m day=%d year=%Y dayname="%A" monthname="%B")T'
<span class="anchor" id="line-2-94"></span>eval "$d"</pre><span class="anchor" id="line-1496"></span><p class="line862">Remember things like month or day names are locale-dependent, hence the quotes around <tt class="backtick">%A</tt> or <tt class="backtick">%B</tt> to avoid problems in locales where day or month names contain spaces or other special characters for the shell. <span class="anchor" id="line-1497"></span><span class="anchor" id="line-1498"></span><p class="line874">Or, you may retrieve a timestamp in epoch format (seconds since the start of 1970), and then use that to generate human-readable date/time fields as needed. <span class="anchor" id="line-1499"></span><span class="anchor" id="line-1500"></span><p class="line867"><span class="anchor" id="line-1501"></span><span class="anchor" id="line-1502"></span><span class="anchor" id="line-1503"></span><span class="anchor" id="line-1504"></span><span class="anchor" id="line-1505"></span><span class="anchor" id="line-1506"></span><pre><span class="anchor" id="line-1-140"></span># Requires bash 4.2 or above
<span class="anchor" id="line-2-95"></span>printf -v now '%(%s)T' -1        # Or now=$EPOCHSECONDS in bash 5.0
<span class="anchor" id="line-3-67"></span>                                 # -1 may be omitted in 4.3 or above
<span class="anchor" id="line-4-37"></span>printf -v month '%(%m)T' "$now"
<span class="anchor" id="line-5-25"></span>printf -v day '%(%d)T' "$now"</pre><span class="anchor" id="line-1507"></span><p class="line862">If your system's <tt class="backtick">strftime()</tt> doesn't support <tt class="backtick">%s</tt>, you can get the epoch time with: <span class="anchor" id="line-1508"></span><span class="anchor" id="line-1509"></span><p class="line867"><span class="anchor" id="line-1510"></span><span class="anchor" id="line-1511"></span><pre><span class="anchor" id="line-1-141"></span>now=$(awk 'BEGIN{srand(); print srand()}')</pre><span class="anchor" id="line-1512"></span><p class="line867"><span class="anchor" id="pf59"></span> <span class="anchor" id="line-1513"></span><span class="anchor" id="line-1514"></span><p class="line867">
<h2 id="i.3D.24.28.28_10.23.24i_.29.29">59. i=$(( 10#$i ))</h2>
<span class="anchor" id="line-1515"></span><p class="line862">Forced base 10 interpretation only works with signless numbers.  As long as <tt class="backtick">$i</tt> contains a string of digits with no leading <tt class="backtick">-</tt> or <tt class="backtick">+</tt>, everything is fine.  But if <tt class="backtick">$i</tt> might be negative, this conversion could fail, either noisily (with an error message), or even worse, silently (simply yielding the wrong result). <span class="anchor" id="line-1516"></span><span class="anchor" id="line-1517"></span><p class="line862">If there's any chance <tt class="backtick">$i</tt> could be negative, use this instead: <span class="anchor" id="line-1518"></span><span class="anchor" id="line-1519"></span><p class="line867"><span class="anchor" id="line-1520"></span><span class="anchor" id="line-1521"></span><pre><span class="anchor" id="line-1-142"></span>i=$(( ${i%%[!+-]*}10#${i#[-+]} ))</pre><span class="anchor" id="line-1522"></span><p class="line862">For explanations, please see <a href="/ArithmeticExpression">ArithmeticExpression</a>. <span class="anchor" id="line-1523"></span><span class="anchor" id="line-1524"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-1525"></span><a href="/CategoryShell">CategoryShell</a> <a href="/CategoryBashguide">CategoryBashguide</a> <span class="anchor" id="line-1526"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">BashPitfalls  (last edited 2020-06-18 19:11:42 by <span title="GreyCat @ wooledge.org[209.142.155.49]"><a href="/GreyCat" title="GreyCat @ wooledge.org[209.142.155.49]">GreyCat</a></span>)</p>

<div id="pagebottom"></div>
</div>


<div id="footer">
<ul class="editbar"><li><a href="/BashPitfalls?action=edit&amp;editor=text" name="texteditlink" rel="nofollow">Edit (Text)</a></li><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="/BashPitfalls?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="/BashPitfalls?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="/BashPitfalls">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="RenderAsDocbook">Render as Docbook</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
<option value="PackagePages">Package Pages</option>
<option value="SyncPages">Sync Pages</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="Load">Load</option>
<option value="Save">Save</option>
<option value="SlideShow">SlideShow</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>
</html>

